// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64, params GetApplicationByIDParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64, params GetAssetByIDParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Create a speculation context starting at the given block.
	// (POST /v2/blocks/{round}/speculation)
	CreateSpeculation(ctx echo.Context, round uint64) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Executes a batch of contract initializations/calls.
	// (POST /v2/contracts/batch)
	ContractBatchExecute(ctx echo.Context, params ContractBatchExecuteParams) error
	// Creates a new contract with the specified identifier and source code
	// (POST /v2/contracts/{id})
	CreateContract(ctx echo.Context, id string, params CreateContractParams) error
	// Calls a function on a previously initialized contract.
	// (POST /v2/contracts/{id}/call/{function})
	CallContract(ctx echo.Context, id string, function string, params CallContractParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Operates on a speculation object.
	// (POST /v2/speculation/{speculation}/{operation})
	SpeculationOperation(ctx echo.Context, speculation string, operation string) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context, params RawTransactionParams) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context, params TransactionParamsParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
		"format":      true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationByIDParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetByIDParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// CreateSpeculation converts echo context to params.
func (w *ServerInterfaceWrapper) CreateSpeculation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateSpeculation(ctx, round)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// ContractBatchExecute converts echo context to params.
func (w *ServerInterfaceWrapper) ContractBatchExecute(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ContractBatchExecuteParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ContractBatchExecute(ctx, params)
	return err
}

// CreateContract converts echo context to params.
func (w *ServerInterfaceWrapper) CreateContract(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"sender":      true,
		"address":     true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateContractParams
	// ------------- Optional query parameter "sender" -------------
	if paramValue := ctx.QueryParam("sender"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender", ctx.QueryParams(), &params.Sender)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateContract(ctx, id, params)
	return err
}

// CallContract converts echo context to params.
func (w *ServerInterfaceWrapper) CallContract(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
		"sender":      true,
		"address":     true,
		"args":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "function" -------------
	var function string

	err = runtime.BindStyledParameter("simple", false, "function", ctx.Param("function"), &function)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter function: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CallContractParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Optional query parameter "sender" -------------
	if paramValue := ctx.QueryParam("sender"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender", ctx.QueryParams(), &params.Sender)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "args" -------------
	if paramValue := ctx.QueryParam("args"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "args", ctx.QueryParams(), &params.Args)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter args: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CallContract(ctx, id, function, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// SpeculationOperation converts echo context to params.
func (w *ServerInterfaceWrapper) SpeculationOperation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "speculation" -------------
	var speculation string

	err = runtime.BindStyledParameter("simple", false, "speculation", ctx.Param("speculation"), &speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Path parameter "operation" -------------
	var operation string

	err = runtime.BindStyledParameter("simple", false, "operation", ctx.Param("operation"), &operation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter operation: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SpeculationOperation(ctx, speculation, operation)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params RawTransactionParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx, params)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TransactionParamsParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx, params)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.POST("/v2/blocks/:round/speculation", wrapper.CreateSpeculation, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.POST("/v2/contracts/batch", wrapper.ContractBatchExecute, m...)
	router.POST("/v2/contracts/:id", wrapper.CreateContract, m...)
	router.POST("/v2/contracts/:id/call/:function", wrapper.CallContract, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.POST("/v2/speculation/:speculation/:operation", wrapper.SpeculationOperation, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
