// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64, params GetApplicationByIDParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64, params GetAssetByIDParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Create a speculation context starting at the given block.
	// (POST /v2/blocks/{round}/speculation)
	CreateSpeculation(ctx echo.Context, round uint64) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Executes a batch of contract initializations/calls.
	// (POST /v2/contracts/batch)
	ContractBatchExecute(ctx echo.Context, params ContractBatchExecuteParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error

	// (GET /v2/speculation/read/{contract_id}/{key})
	ContractStorageGet(ctx echo.Context, contractId string, key string) error

	// (POST /v2/speculation/write/{contract_id}/{key})
	ContractStorageWrite(ctx echo.Context, contractId string, key string) error
	// Operates on a speculation object.
	// (POST /v2/speculation/{speculation}/{operation})
	SpeculationOperation(ctx echo.Context, speculation string, operation string) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context, params RawTransactionParams) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context, params TransactionParamsParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
		"format":      true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationByIDParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetByIDParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// CreateSpeculation converts echo context to params.
func (w *ServerInterfaceWrapper) CreateSpeculation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateSpeculation(ctx, round)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// ContractBatchExecute converts echo context to params.
func (w *ServerInterfaceWrapper) ContractBatchExecute(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ContractBatchExecuteParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ContractBatchExecute(ctx, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// ContractStorageGet converts echo context to params.
func (w *ServerInterfaceWrapper) ContractStorageGet(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "contract_id" -------------
	var contractId string

	err = runtime.BindStyledParameter("simple", false, "contract_id", ctx.Param("contract_id"), &contractId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter contract_id: %s", err))
	}

	// ------------- Path parameter "key" -------------
	var key string

	err = runtime.BindStyledParameter("simple", false, "key", ctx.Param("key"), &key)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter key: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ContractStorageGet(ctx, contractId, key)
	return err
}

// ContractStorageWrite converts echo context to params.
func (w *ServerInterfaceWrapper) ContractStorageWrite(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "contract_id" -------------
	var contractId string

	err = runtime.BindStyledParameter("simple", false, "contract_id", ctx.Param("contract_id"), &contractId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter contract_id: %s", err))
	}

	// ------------- Path parameter "key" -------------
	var key string

	err = runtime.BindStyledParameter("simple", false, "key", ctx.Param("key"), &key)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter key: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ContractStorageWrite(ctx, contractId, key)
	return err
}

// SpeculationOperation converts echo context to params.
func (w *ServerInterfaceWrapper) SpeculationOperation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "speculation" -------------
	var speculation string

	err = runtime.BindStyledParameter("simple", false, "speculation", ctx.Param("speculation"), &speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Path parameter "operation" -------------
	var operation string

	err = runtime.BindStyledParameter("simple", false, "operation", ctx.Param("operation"), &operation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter operation: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SpeculationOperation(ctx, speculation, operation)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params RawTransactionParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx, params)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TransactionParamsParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx, params)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.POST("/v2/blocks/:round/speculation", wrapper.CreateSpeculation, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.POST("/v2/contracts/batch", wrapper.ContractBatchExecute, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/speculation/read/:contract_id/:key", wrapper.ContractStorageGet, m...)
	router.POST("/v2/speculation/write/:contract_id/:key", wrapper.ContractStorageWrite, m...)
	router.POST("/v2/speculation/:speculation/:operation", wrapper.SpeculationOperation, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"J8sdAQA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
