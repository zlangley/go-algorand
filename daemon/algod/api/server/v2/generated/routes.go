// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64, params GetApplicationByIDParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64, params GetAssetByIDParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Create a speculation context starting at the given block.
	// (POST /v2/blocks/{round}/speculation)
	CreateSpeculation(ctx echo.Context, round uint64) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Executes a batch of contract initializations/calls.
	// (POST /v2/contracts/batch)
	ContractBatchExecute(ctx echo.Context, params ContractBatchExecuteParams) error
	// Creates a new contract with the specified identifier and source code
	// (POST /v2/contracts/{id})
	CreateContract(ctx echo.Context, id string, params CreateContractParams) error
	// Calls a function on a previously initialized contract.
	// (POST /v2/contracts/{id}/call/{function})
	CallContract(ctx echo.Context, id string, function string, params CallContractParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Operates on a speculation object.
	// (POST /v2/speculation/{speculation}/{operation})
	SpeculationOperation(ctx echo.Context, speculation string, operation string) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context, params RawTransactionParams) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context, params TransactionParamsParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
		"format":      true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationByIDParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetByIDParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// CreateSpeculation converts echo context to params.
func (w *ServerInterfaceWrapper) CreateSpeculation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateSpeculation(ctx, round)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// ContractBatchExecute converts echo context to params.
func (w *ServerInterfaceWrapper) ContractBatchExecute(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ContractBatchExecuteParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ContractBatchExecute(ctx, params)
	return err
}

// CreateContract converts echo context to params.
func (w *ServerInterfaceWrapper) CreateContract(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"sender":      true,
		"address":     true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateContractParams
	// ------------- Optional query parameter "sender" -------------
	if paramValue := ctx.QueryParam("sender"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender", ctx.QueryParams(), &params.Sender)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateContract(ctx, id, params)
	return err
}

// CallContract converts echo context to params.
func (w *ServerInterfaceWrapper) CallContract(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
		"sender":      true,
		"address":     true,
		"args":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "function" -------------
	var function string

	err = runtime.BindStyledParameter("simple", false, "function", ctx.Param("function"), &function)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter function: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CallContractParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Optional query parameter "sender" -------------
	if paramValue := ctx.QueryParam("sender"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender", ctx.QueryParams(), &params.Sender)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "args" -------------
	if paramValue := ctx.QueryParam("args"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "args", ctx.QueryParams(), &params.Args)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter args: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CallContract(ctx, id, function, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// SpeculationOperation converts echo context to params.
func (w *ServerInterfaceWrapper) SpeculationOperation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "speculation" -------------
	var speculation string

	err = runtime.BindStyledParameter("simple", false, "speculation", ctx.Param("speculation"), &speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Path parameter "operation" -------------
	var operation string

	err = runtime.BindStyledParameter("simple", false, "operation", ctx.Param("operation"), &operation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter operation: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SpeculationOperation(ctx, speculation, operation)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params RawTransactionParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx, params)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TransactionParamsParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx, params)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.POST("/v2/blocks/:round/speculation", wrapper.CreateSpeculation, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.POST("/v2/contracts/batch", wrapper.ContractBatchExecute, m...)
	router.POST("/v2/contracts/:id", wrapper.CreateContract, m...)
	router.POST("/v2/contracts/:id/call/:function", wrapper.CallContract, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.POST("/v2/speculation/:speculation/:operation", wrapper.SpeculationOperation, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
