// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64, params GetApplicationByIDParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64, params GetAssetByIDParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Create a speculation context starting at the given block.
	// (POST /v2/blocks/{round}/speculation)
	CreateSpeculation(ctx echo.Context, round uint64) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Executes a batch of contract initializations/calls.
	// (POST /v2/contracts/batch)
	ContractBatchExecute(ctx echo.Context, params ContractBatchExecuteParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error

	// (GET /v2/speculation/get/{contract_id}/{key})
	ContractStorageGet(ctx echo.Context, contractId string, key string) error

	// (GET /v2/speculation/get_with_prefix/{contract_id}/{key_prefix})
	ContractStorageGetWithPrefix(ctx echo.Context, contractId string, keyPrefix string) error

	// (POST /v2/speculation/write/{contract_id}/{key})
	ContractStorageWrite(ctx echo.Context, contractId string, key string) error
	// Operates on a speculation object.
	// (POST /v2/speculation/{speculation}/{operation})
	SpeculationOperation(ctx echo.Context, speculation string, operation string) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context, params RawTransactionParams) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context, params TransactionParamsParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
		"format":      true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationByIDParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetByIDParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// CreateSpeculation converts echo context to params.
func (w *ServerInterfaceWrapper) CreateSpeculation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateSpeculation(ctx, round)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// ContractBatchExecute converts echo context to params.
func (w *ServerInterfaceWrapper) ContractBatchExecute(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ContractBatchExecuteParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ContractBatchExecute(ctx, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// ContractStorageGet converts echo context to params.
func (w *ServerInterfaceWrapper) ContractStorageGet(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "contract_id" -------------
	var contractId string

	err = runtime.BindStyledParameter("simple", false, "contract_id", ctx.Param("contract_id"), &contractId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter contract_id: %s", err))
	}

	// ------------- Path parameter "key" -------------
	var key string

	err = runtime.BindStyledParameter("simple", false, "key", ctx.Param("key"), &key)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter key: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ContractStorageGet(ctx, contractId, key)
	return err
}

// ContractStorageGetWithPrefix converts echo context to params.
func (w *ServerInterfaceWrapper) ContractStorageGetWithPrefix(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "contract_id" -------------
	var contractId string

	err = runtime.BindStyledParameter("simple", false, "contract_id", ctx.Param("contract_id"), &contractId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter contract_id: %s", err))
	}

	// ------------- Path parameter "key_prefix" -------------
	var keyPrefix string

	err = runtime.BindStyledParameter("simple", false, "key_prefix", ctx.Param("key_prefix"), &keyPrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter key_prefix: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ContractStorageGetWithPrefix(ctx, contractId, keyPrefix)
	return err
}

// ContractStorageWrite converts echo context to params.
func (w *ServerInterfaceWrapper) ContractStorageWrite(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "contract_id" -------------
	var contractId string

	err = runtime.BindStyledParameter("simple", false, "contract_id", ctx.Param("contract_id"), &contractId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter contract_id: %s", err))
	}

	// ------------- Path parameter "key" -------------
	var key string

	err = runtime.BindStyledParameter("simple", false, "key", ctx.Param("key"), &key)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter key: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ContractStorageWrite(ctx, contractId, key)
	return err
}

// SpeculationOperation converts echo context to params.
func (w *ServerInterfaceWrapper) SpeculationOperation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "speculation" -------------
	var speculation string

	err = runtime.BindStyledParameter("simple", false, "speculation", ctx.Param("speculation"), &speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Path parameter "operation" -------------
	var operation string

	err = runtime.BindStyledParameter("simple", false, "operation", ctx.Param("operation"), &operation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter operation: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SpeculationOperation(ctx, speculation, operation)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params RawTransactionParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx, params)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TransactionParamsParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx, params)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.POST("/v2/blocks/:round/speculation", wrapper.CreateSpeculation, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.POST("/v2/contracts/batch", wrapper.ContractBatchExecute, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/speculation/get/:contract_id/:key", wrapper.ContractStorageGet, m...)
	router.GET("/v2/speculation/get_with_prefix/:contract_id/:key_prefix", wrapper.ContractStorageGetWithPrefix, m...)
	router.POST("/v2/speculation/write/:contract_id/:key", wrapper.ContractStorageWrite, m...)
	router.POST("/v2/speculation/:speculation/:operation", wrapper.SpeculationOperation, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
