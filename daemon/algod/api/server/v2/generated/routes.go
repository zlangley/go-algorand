// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64, params GetApplicationByIDParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64, params GetAssetByIDParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Create a speculation context starting at the given block.
	// (POST /v2/blocks/{round}/speculation)
	CreateSpeculation(ctx echo.Context, round uint64) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Executes a batch of contract initializations/calls.
	// (POST /v2/contracts/batch)
	ContractBatchExecute(ctx echo.Context, params ContractBatchExecuteParams) error
	// Creates a new contract with the specified identifier and source code
	// (POST /v2/contracts/{id})
	CreateContract(ctx echo.Context, id string, params CreateContractParams) error
	// Calls a function on a previously initialized contract.
	// (POST /v2/contracts/{id}/call/{function})
	CallContract(ctx echo.Context, id string, function string, params CallContractParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Operates on a speculation object.
	// (POST /v2/speculation/{speculation}/{operation})
	SpeculationOperation(ctx echo.Context, speculation string, operation string) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context, params RawTransactionParams) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context, params TransactionParamsParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
		"format":      true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationByIDParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetByIDParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// CreateSpeculation converts echo context to params.
func (w *ServerInterfaceWrapper) CreateSpeculation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateSpeculation(ctx, round)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// ContractBatchExecute converts echo context to params.
func (w *ServerInterfaceWrapper) ContractBatchExecute(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ContractBatchExecuteParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ContractBatchExecute(ctx, params)
	return err
}

// CreateContract converts echo context to params.
func (w *ServerInterfaceWrapper) CreateContract(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateContractParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateContract(ctx, id, params)
	return err
}

// CallContract converts echo context to params.
func (w *ServerInterfaceWrapper) CallContract(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
		"args":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "function" -------------
	var function string

	err = runtime.BindStyledParameter("simple", false, "function", ctx.Param("function"), &function)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter function: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CallContractParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Optional query parameter "args" -------------
	if paramValue := ctx.QueryParam("args"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "args", ctx.QueryParams(), &params.Args)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter args: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CallContract(ctx, id, function, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// SpeculationOperation converts echo context to params.
func (w *ServerInterfaceWrapper) SpeculationOperation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "speculation" -------------
	var speculation string

	err = runtime.BindStyledParameter("simple", false, "speculation", ctx.Param("speculation"), &speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Path parameter "operation" -------------
	var operation string

	err = runtime.BindStyledParameter("simple", false, "operation", ctx.Param("operation"), &operation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter operation: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SpeculationOperation(ctx, speculation, operation)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params RawTransactionParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx, params)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TransactionParamsParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx, params)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.POST("/v2/blocks/:round/speculation", wrapper.CreateSpeculation, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.POST("/v2/contracts/batch", wrapper.ContractBatchExecute, m...)
	router.POST("/v2/contracts/:id", wrapper.CreateContract, m...)
	router.POST("/v2/contracts/:id/call/:function", wrapper.CallContract, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.POST("/v2/speculation/:speculation/:operation", wrapper.SpeculationOperation, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"r/5/AAAA//9IPuhz3xgBAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
