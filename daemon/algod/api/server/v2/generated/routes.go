// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64, params GetApplicationByIDParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64, params GetAssetByIDParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Create a speculation context starting at the given block.
	// (POST /v2/blocks/{round}/speculation)
	CreateSpeculation(ctx echo.Context, round uint64) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Executes a batch of contract initializations/calls.
	// (POST /v2/contracts/batch)
	ContractBatchExecute(ctx echo.Context, params ContractBatchExecuteParams) error
	// Creates a new contract with the specified identifier and source code
	// (POST /v2/contracts/{id})
	CreateContract(ctx echo.Context, id string, params CreateContractParams) error
	// Calls a function on a previously initialized contract.
	// (POST /v2/contracts/{id}/call/{function})
	CallContract(ctx echo.Context, id string, function string, params CallContractParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Operates on a speculation object.
	// (POST /v2/speculation/{speculation}/{operation})
	SpeculationOperation(ctx echo.Context, speculation string, operation string) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context, params RawTransactionParams) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context, params TransactionParamsParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
		"format":      true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationByIDParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetByIDParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// CreateSpeculation converts echo context to params.
func (w *ServerInterfaceWrapper) CreateSpeculation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateSpeculation(ctx, round)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// ContractBatchExecute converts echo context to params.
func (w *ServerInterfaceWrapper) ContractBatchExecute(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ContractBatchExecuteParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ContractBatchExecute(ctx, params)
	return err
}

// CreateContract converts echo context to params.
func (w *ServerInterfaceWrapper) CreateContract(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"sender":      true,
		"address":     true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateContractParams
	// ------------- Optional query parameter "sender" -------------
	if paramValue := ctx.QueryParam("sender"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender", ctx.QueryParams(), &params.Sender)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateContract(ctx, id, params)
	return err
}

// CallContract converts echo context to params.
func (w *ServerInterfaceWrapper) CallContract(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
		"sender":      true,
		"address":     true,
		"args":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "function" -------------
	var function string

	err = runtime.BindStyledParameter("simple", false, "function", ctx.Param("function"), &function)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter function: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CallContractParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Optional query parameter "sender" -------------
	if paramValue := ctx.QueryParam("sender"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender", ctx.QueryParams(), &params.Sender)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "args" -------------
	if paramValue := ctx.QueryParam("args"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "args", ctx.QueryParams(), &params.Args)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter args: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CallContract(ctx, id, function, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// SpeculationOperation converts echo context to params.
func (w *ServerInterfaceWrapper) SpeculationOperation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "speculation" -------------
	var speculation string

	err = runtime.BindStyledParameter("simple", false, "speculation", ctx.Param("speculation"), &speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Path parameter "operation" -------------
	var operation string

	err = runtime.BindStyledParameter("simple", false, "operation", ctx.Param("operation"), &operation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter operation: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SpeculationOperation(ctx, speculation, operation)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params RawTransactionParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx, params)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TransactionParamsParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx, params)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.POST("/v2/blocks/:round/speculation", wrapper.CreateSpeculation, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.POST("/v2/contracts/batch", wrapper.ContractBatchExecute, m...)
	router.POST("/v2/contracts/:id", wrapper.CreateContract, m...)
	router.POST("/v2/contracts/:id/call/:function", wrapper.CallContract, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.POST("/v2/speculation/:speculation/:operation", wrapper.SpeculationOperation, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"oBpGVx+u/n8AAAD//6muwcEQLwEA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
