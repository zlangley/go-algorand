// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64, params GetApplicationByIDParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64, params GetAssetByIDParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Create a speculation context starting at the given block.
	// (POST /v2/blocks/{round}/speculation)
	CreateSpeculation(ctx echo.Context, round uint64) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Executes a batch of contract initializations/calls.
	// (POST /v2/contracts/batch)
	ContractBatchExecute(ctx echo.Context, params ContractBatchExecuteParams) error
	// Creates a new contract with the specified identifier and source code
	// (POST /v2/contracts/{id})
	CreateContract(ctx echo.Context, id string, params CreateContractParams) error
	// Calls a function on a previously initialized contract.
	// (POST /v2/contracts/{id}/call/{function})
	CallContract(ctx echo.Context, id string, function string, params CallContractParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Operates on a speculation object.
	// (POST /v2/speculation/{speculation}/{operation})
	SpeculationOperation(ctx echo.Context, speculation string, operation string) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context, params RawTransactionParams) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context, params TransactionParamsParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
		"format":      true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationByIDParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetByIDParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// CreateSpeculation converts echo context to params.
func (w *ServerInterfaceWrapper) CreateSpeculation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateSpeculation(ctx, round)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// ContractBatchExecute converts echo context to params.
func (w *ServerInterfaceWrapper) ContractBatchExecute(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ContractBatchExecuteParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ContractBatchExecute(ctx, params)
	return err
}

// CreateContract converts echo context to params.
func (w *ServerInterfaceWrapper) CreateContract(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"sender":      true,
		"address":     true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateContractParams
	// ------------- Optional query parameter "sender" -------------
	if paramValue := ctx.QueryParam("sender"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender", ctx.QueryParams(), &params.Sender)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateContract(ctx, id, params)
	return err
}

// CallContract converts echo context to params.
func (w *ServerInterfaceWrapper) CallContract(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
		"sender":      true,
		"address":     true,
		"args":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "function" -------------
	var function string

	err = runtime.BindStyledParameter("simple", false, "function", ctx.Param("function"), &function)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter function: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CallContractParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Optional query parameter "sender" -------------
	if paramValue := ctx.QueryParam("sender"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender", ctx.QueryParams(), &params.Sender)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "args" -------------
	if paramValue := ctx.QueryParam("args"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "args", ctx.QueryParams(), &params.Args)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter args: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CallContract(ctx, id, function, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// SpeculationOperation converts echo context to params.
func (w *ServerInterfaceWrapper) SpeculationOperation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "speculation" -------------
	var speculation string

	err = runtime.BindStyledParameter("simple", false, "speculation", ctx.Param("speculation"), &speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Path parameter "operation" -------------
	var operation string

	err = runtime.BindStyledParameter("simple", false, "operation", ctx.Param("operation"), &operation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter operation: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SpeculationOperation(ctx, speculation, operation)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params RawTransactionParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx, params)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TransactionParamsParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx, params)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.POST("/v2/blocks/:round/speculation", wrapper.CreateSpeculation, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.POST("/v2/contracts/batch", wrapper.ContractBatchExecute, m...)
	router.POST("/v2/contracts/:id", wrapper.CreateContract, m...)
	router.POST("/v2/contracts/:id/call/:function", wrapper.CallContract, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.POST("/v2/speculation/:speculation/:operation", wrapper.SpeculationOperation, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
