// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64, params GetApplicationByIDParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64, params GetAssetByIDParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Create a speculation context starting at the given block.
	// (POST /v2/blocks/{round}/speculation)
	CreateSpeculation(ctx echo.Context, round uint64) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Creates a new contract with the specified identifier and source code
	// (POST /v2/contracts/{id})
	CreateContract(ctx echo.Context, id string, params CreateContractParams) error
	// Calls a function on a previously initialized contract.
	// (POST /v2/contracts/{id}/call/{function})
	CallContract(ctx echo.Context, id string, function string, params CallContractParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Operates on a speculation object.
	// (POST /v2/speculation/{speculation}/{operation})
	SpeculationOperation(ctx echo.Context, speculation string, operation string) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context, params RawTransactionParams) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context, params TransactionParamsParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
		"format":      true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationByIDParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetByIDParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// CreateSpeculation converts echo context to params.
func (w *ServerInterfaceWrapper) CreateSpeculation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateSpeculation(ctx, round)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// CreateContract converts echo context to params.
func (w *ServerInterfaceWrapper) CreateContract(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateContractParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateContract(ctx, id, params)
	return err
}

// CallContract converts echo context to params.
func (w *ServerInterfaceWrapper) CallContract(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
		"args":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "function" -------------
	var function string

	err = runtime.BindStyledParameter("simple", false, "function", ctx.Param("function"), &function)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter function: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CallContractParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Optional query parameter "args" -------------
	if paramValue := ctx.QueryParam("args"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "args", ctx.QueryParams(), &params.Args)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter args: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CallContract(ctx, id, function, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// SpeculationOperation converts echo context to params.
func (w *ServerInterfaceWrapper) SpeculationOperation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "speculation" -------------
	var speculation string

	err = runtime.BindStyledParameter("simple", false, "speculation", ctx.Param("speculation"), &speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Path parameter "operation" -------------
	var operation string

	err = runtime.BindStyledParameter("simple", false, "operation", ctx.Param("operation"), &operation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter operation: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SpeculationOperation(ctx, speculation, operation)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params RawTransactionParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx, params)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TransactionParamsParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx, params)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.POST("/v2/blocks/:round/speculation", wrapper.CreateSpeculation, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.POST("/v2/contracts/:id", wrapper.CreateContract, m...)
	router.POST("/v2/contracts/:id/call/:function", wrapper.CallContract, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.POST("/v2/speculation/:speculation/:operation", wrapper.SpeculationOperation, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
