// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64, params GetApplicationByIDParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64, params GetAssetByIDParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Create a speculation context starting at the given block.
	// (POST /v2/blocks/{round}/speculation)
	CreateSpeculation(ctx echo.Context, round uint64) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Creates a new contract with the specified identifier and source code
	// (POST /v2/contracts/{id})
	CreateContract(ctx echo.Context, id string, params CreateContractParams) error
	// Calls a function on a previously initialized contract.
	// (POST /v2/contracts/{id}/call/{function})
	CallContract(ctx echo.Context, id string, function string, params CallContractParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Operates on a speculation object.
	// (POST /v2/speculation/{speculation}/{operation})
	SpeculationOperation(ctx echo.Context, speculation string, operation string) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context, params RawTransactionParams) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context, params TransactionParamsParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
		"format":      true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationByIDParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetByIDParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// CreateSpeculation converts echo context to params.
func (w *ServerInterfaceWrapper) CreateSpeculation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateSpeculation(ctx, round)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// CreateContract converts echo context to params.
func (w *ServerInterfaceWrapper) CreateContract(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateContractParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateContract(ctx, id, params)
	return err
}

// CallContract converts echo context to params.
func (w *ServerInterfaceWrapper) CallContract(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
		"args":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "function" -------------
	var function string

	err = runtime.BindStyledParameter("simple", false, "function", ctx.Param("function"), &function)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter function: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CallContractParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Optional query parameter "args" -------------
	if paramValue := ctx.QueryParam("args"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "args", ctx.QueryParams(), &params.Args)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter args: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CallContract(ctx, id, function, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// SpeculationOperation converts echo context to params.
func (w *ServerInterfaceWrapper) SpeculationOperation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "speculation" -------------
	var speculation string

	err = runtime.BindStyledParameter("simple", false, "speculation", ctx.Param("speculation"), &speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Path parameter "operation" -------------
	var operation string

	err = runtime.BindStyledParameter("simple", false, "operation", ctx.Param("operation"), &operation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter operation: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SpeculationOperation(ctx, speculation, operation)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params RawTransactionParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx, params)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TransactionParamsParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx, params)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.POST("/v2/blocks/:round/speculation", wrapper.CreateSpeculation, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.POST("/v2/contracts/:id", wrapper.CreateContract, m...)
	router.POST("/v2/contracts/:id/call/:function", wrapper.CallContract, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.POST("/v2/speculation/:speculation/:operation", wrapper.SpeculationOperation, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
