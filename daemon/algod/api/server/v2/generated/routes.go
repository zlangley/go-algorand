// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64, params GetApplicationByIDParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64, params GetAssetByIDParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Create a speculation context starting at the given block.
	// (POST /v2/blocks/{round}/speculation)
	CreateSpeculation(ctx echo.Context, round uint64) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Executes a batch of contract initializations/calls.
	// (POST /v2/contracts/batch)
	ContractBatchExecute(ctx echo.Context, params ContractBatchExecuteParams) error
	// Creates a new contract with the specified identifier and source code
	// (POST /v2/contracts/{id})
	CreateContract(ctx echo.Context, id string, params CreateContractParams) error
	// Calls a function on a previously initialized contract.
	// (POST /v2/contracts/{id}/call/{function})
	CallContract(ctx echo.Context, id string, function string, params CallContractParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Operates on a speculation object.
	// (POST /v2/speculation/{speculation}/{operation})
	SpeculationOperation(ctx echo.Context, speculation string, operation string) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context, params RawTransactionParams) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context, params TransactionParamsParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
		"format":      true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationByIDParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetByIDParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// CreateSpeculation converts echo context to params.
func (w *ServerInterfaceWrapper) CreateSpeculation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateSpeculation(ctx, round)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// ContractBatchExecute converts echo context to params.
func (w *ServerInterfaceWrapper) ContractBatchExecute(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ContractBatchExecuteParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ContractBatchExecute(ctx, params)
	return err
}

// CreateContract converts echo context to params.
func (w *ServerInterfaceWrapper) CreateContract(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"sender":      true,
		"address":     true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateContractParams
	// ------------- Optional query parameter "sender" -------------
	if paramValue := ctx.QueryParam("sender"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender", ctx.QueryParams(), &params.Sender)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateContract(ctx, id, params)
	return err
}

// CallContract converts echo context to params.
func (w *ServerInterfaceWrapper) CallContract(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
		"sender":      true,
		"address":     true,
		"args":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "function" -------------
	var function string

	err = runtime.BindStyledParameter("simple", false, "function", ctx.Param("function"), &function)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter function: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CallContractParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Optional query parameter "sender" -------------
	if paramValue := ctx.QueryParam("sender"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender", ctx.QueryParams(), &params.Sender)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "args" -------------
	if paramValue := ctx.QueryParam("args"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "args", ctx.QueryParams(), &params.Args)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter args: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CallContract(ctx, id, function, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// SpeculationOperation converts echo context to params.
func (w *ServerInterfaceWrapper) SpeculationOperation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "speculation" -------------
	var speculation string

	err = runtime.BindStyledParameter("simple", false, "speculation", ctx.Param("speculation"), &speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Path parameter "operation" -------------
	var operation string

	err = runtime.BindStyledParameter("simple", false, "operation", ctx.Param("operation"), &operation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter operation: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SpeculationOperation(ctx, speculation, operation)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params RawTransactionParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx, params)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TransactionParamsParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx, params)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.POST("/v2/blocks/:round/speculation", wrapper.CreateSpeculation, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.POST("/v2/contracts/batch", wrapper.ContractBatchExecute, m...)
	router.POST("/v2/contracts/:id", wrapper.CreateContract, m...)
	router.POST("/v2/contracts/:id/call/:function", wrapper.CallContract, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.POST("/v2/speculation/:speculation/:operation", wrapper.SpeculationOperation, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
