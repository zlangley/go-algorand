// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64, params GetApplicationByIDParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64, params GetAssetByIDParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Create a speculation context starting at the given block.
	// (POST /v2/blocks/{round}/speculation)
	CreateSpeculation(ctx echo.Context, round uint64) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Executes a batch of contract initializations/calls.
	// (POST /v2/contracts/batch)
	ContractBatchExecute(ctx echo.Context, params ContractBatchExecuteParams) error
	// Creates a new contract with the specified identifier and source code
	// (POST /v2/contracts/{id})
	CreateContract(ctx echo.Context, id string, params CreateContractParams) error
	// Calls a function on a previously initialized contract.
	// (POST /v2/contracts/{id}/call/{function})
	CallContract(ctx echo.Context, id string, function string, params CallContractParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Operates on a speculation object.
	// (POST /v2/speculation/{speculation}/{operation})
	SpeculationOperation(ctx echo.Context, speculation string, operation string) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context, params RawTransactionParams) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context, params TransactionParamsParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
		"format":      true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationByIDParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetByIDParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// CreateSpeculation converts echo context to params.
func (w *ServerInterfaceWrapper) CreateSpeculation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateSpeculation(ctx, round)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// ContractBatchExecute converts echo context to params.
func (w *ServerInterfaceWrapper) ContractBatchExecute(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ContractBatchExecuteParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ContractBatchExecute(ctx, params)
	return err
}

// CreateContract converts echo context to params.
func (w *ServerInterfaceWrapper) CreateContract(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"sender":      true,
		"address":     true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateContractParams
	// ------------- Optional query parameter "sender" -------------
	if paramValue := ctx.QueryParam("sender"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender", ctx.QueryParams(), &params.Sender)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateContract(ctx, id, params)
	return err
}

// CallContract converts echo context to params.
func (w *ServerInterfaceWrapper) CallContract(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
		"sender":      true,
		"address":     true,
		"args":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "function" -------------
	var function string

	err = runtime.BindStyledParameter("simple", false, "function", ctx.Param("function"), &function)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter function: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CallContractParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Optional query parameter "sender" -------------
	if paramValue := ctx.QueryParam("sender"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender", ctx.QueryParams(), &params.Sender)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "args" -------------
	if paramValue := ctx.QueryParam("args"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "args", ctx.QueryParams(), &params.Args)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter args: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CallContract(ctx, id, function, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// SpeculationOperation converts echo context to params.
func (w *ServerInterfaceWrapper) SpeculationOperation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "speculation" -------------
	var speculation string

	err = runtime.BindStyledParameter("simple", false, "speculation", ctx.Param("speculation"), &speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Path parameter "operation" -------------
	var operation string

	err = runtime.BindStyledParameter("simple", false, "operation", ctx.Param("operation"), &operation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter operation: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SpeculationOperation(ctx, speculation, operation)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params RawTransactionParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx, params)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TransactionParamsParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx, params)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.POST("/v2/blocks/:round/speculation", wrapper.CreateSpeculation, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.POST("/v2/contracts/batch", wrapper.ContractBatchExecute, m...)
	router.POST("/v2/contracts/:id", wrapper.CreateContract, m...)
	router.POST("/v2/contracts/:id/call/:function", wrapper.CallContract, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.POST("/v2/speculation/:speculation/:operation", wrapper.SpeculationOperation, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AAAA///E5BJl/jABAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
