// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64, params GetApplicationByIDParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64, params GetAssetByIDParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Create a speculation context starting at the given block.
	// (POST /v2/blocks/{round}/speculation)
	CreateSpeculation(ctx echo.Context, round uint64) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Executes a batch of contract initializations/calls.
	// (POST /v2/contracts/batch)
	ContractBatchExecute(ctx echo.Context, params ContractBatchExecuteParams) error
	// Creates a new contract with the specified identifier and source code
	// (POST /v2/contracts/{id})
	CreateContract(ctx echo.Context, id string, params CreateContractParams) error
	// Calls a function on a previously initialized contract.
	// (POST /v2/contracts/{id}/call/{function})
	CallContract(ctx echo.Context, id string, function string, params CallContractParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Operates on a speculation object.
	// (POST /v2/speculation/{speculation}/{operation})
	SpeculationOperation(ctx echo.Context, speculation string, operation string) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context, params RawTransactionParams) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context, params TransactionParamsParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
		"format":      true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationByIDParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetByIDParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// CreateSpeculation converts echo context to params.
func (w *ServerInterfaceWrapper) CreateSpeculation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateSpeculation(ctx, round)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// ContractBatchExecute converts echo context to params.
func (w *ServerInterfaceWrapper) ContractBatchExecute(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ContractBatchExecuteParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ContractBatchExecute(ctx, params)
	return err
}

// CreateContract converts echo context to params.
func (w *ServerInterfaceWrapper) CreateContract(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"sender":      true,
		"address":     true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateContractParams
	// ------------- Optional query parameter "sender" -------------
	if paramValue := ctx.QueryParam("sender"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender", ctx.QueryParams(), &params.Sender)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateContract(ctx, id, params)
	return err
}

// CallContract converts echo context to params.
func (w *ServerInterfaceWrapper) CallContract(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
		"sender":      true,
		"address":     true,
		"args":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "function" -------------
	var function string

	err = runtime.BindStyledParameter("simple", false, "function", ctx.Param("function"), &function)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter function: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CallContractParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Optional query parameter "sender" -------------
	if paramValue := ctx.QueryParam("sender"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender", ctx.QueryParams(), &params.Sender)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "args" -------------
	if paramValue := ctx.QueryParam("args"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "args", ctx.QueryParams(), &params.Args)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter args: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CallContract(ctx, id, function, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// SpeculationOperation converts echo context to params.
func (w *ServerInterfaceWrapper) SpeculationOperation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "speculation" -------------
	var speculation string

	err = runtime.BindStyledParameter("simple", false, "speculation", ctx.Param("speculation"), &speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Path parameter "operation" -------------
	var operation string

	err = runtime.BindStyledParameter("simple", false, "operation", ctx.Param("operation"), &operation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter operation: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SpeculationOperation(ctx, speculation, operation)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params RawTransactionParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx, params)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TransactionParamsParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx, params)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.POST("/v2/blocks/:round/speculation", wrapper.CreateSpeculation, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.POST("/v2/contracts/batch", wrapper.ContractBatchExecute, m...)
	router.POST("/v2/contracts/:id", wrapper.CreateContract, m...)
	router.POST("/v2/contracts/:id/call/:function", wrapper.CallContract, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.POST("/v2/speculation/:speculation/:operation", wrapper.SpeculationOperation, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"v/qfAAAA//+uxOhgFRsBAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
