// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64, params GetApplicationByIDParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64, params GetAssetByIDParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Create a speculation context starting at the given block.
	// (POST /v2/blocks/{round}/speculation)
	CreateSpeculation(ctx echo.Context, round uint64) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Run AlgoClarity code and update the speculative context
	// (POST /v2/speculation/{speculation}/kalgo)
	SpeculationRun(ctx echo.Context, speculation string) error
	// Operates on a speculation object.
	// (POST /v2/speculation/{speculation}/{operation})
	SpeculationOperation(ctx echo.Context, speculation string, operation string) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context, params RawTransactionParams) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context, params TransactionParamsParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
		"format":      true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationByIDParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetByIDParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// CreateSpeculation converts echo context to params.
func (w *ServerInterfaceWrapper) CreateSpeculation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateSpeculation(ctx, round)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// SpeculationRun converts echo context to params.
func (w *ServerInterfaceWrapper) SpeculationRun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "speculation" -------------
	var speculation string

	err = runtime.BindStyledParameter("simple", false, "speculation", ctx.Param("speculation"), &speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SpeculationRun(ctx, speculation)
	return err
}

// SpeculationOperation converts echo context to params.
func (w *ServerInterfaceWrapper) SpeculationOperation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "speculation" -------------
	var speculation string

	err = runtime.BindStyledParameter("simple", false, "speculation", ctx.Param("speculation"), &speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Path parameter "operation" -------------
	var operation string

	err = runtime.BindStyledParameter("simple", false, "operation", ctx.Param("operation"), &operation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter operation: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SpeculationOperation(ctx, speculation, operation)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params RawTransactionParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx, params)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TransactionParamsParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx, params)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.POST("/v2/blocks/:round/speculation", wrapper.CreateSpeculation, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.POST("/v2/speculation/:speculation/kalgo", wrapper.SpeculationRun, m...)
	router.POST("/v2/speculation/:speculation/:operation", wrapper.SpeculationOperation, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+x9/XfbtpLov4LV7jlJuqLlfPU2Pqdnnxunrd9N0pzY7d63cV4vRI4kXJMALwDaUvP8",
	"v7+DAUCCJCjJH/nq1U+JRXwMBoOZwcxg5sMoFUUpOHCtRgcfRiWVtAANEv+iaSoqrhOWmb8yUKlkpWaC",
	"jw78N6K0ZHw+Go+Y+bWkejEajzgtoGlj+o9HEv5ZMQnZ6EDLCsYjlS6goGZgvSpN63qkZTIXiRvi0A5x",
	"fDS6WvOBZpkEpfpQ/sLzFWE8zasMiJaUK5qaT4pcMr0gesEUcZ0J40RwIGJG9KLVmMwY5Jna84v8ZwVy",
	"FazSTT68pKsGxESKHPpwPhfFlHHwUEENVL0hRAuSwQwbLagmZgYDq2+oBVFAZbogMyE3gGqBCOEFXhWj",
	"g3cjBTwDibuVArvA/84kwB+QaCrnoEfvx7HFzTTIRLMisrRjh30Jqsq1ItgW1zhnF8CJ6bVHXlVKkykQ",
	"ysnbH5+Tx48fPzMLKajWkDkiG1xVM3u4Jtt9dDDKqAb/uU9rNJ8LSXmW1O3f/vgc5z9xC9y2FVUK4ofl",
	"0Hwhx0dDC/AdIyTEuIY57kOL+k2PyKFofp7CTEjYck9s4zvdlHD+z7orKdXpohSM68i+EPxK7OcoDwu6",
	"r+NhNQCt9qXBlDSDvttPnr3/8HD8cP/q398dJv/j/nz6+GrL5T+vx92AgWjDtJISeLpK5hIonpYF5X18",
	"vHX0oBaiyjOyoBe4+bRAVu/6EtPXss4LmleGTlgqxWE+F4pQR0YZzGiVa+InJhXPDZsyozlqJ0yRUooL",
	"lkE2Ntz3csHSBUmpskNgO3LJ8tzQYKUgG6K1+OrWHKarECUGrhvhAxf05SKjWdcGTMASuUGS5kJBosUG",
	"8eQlDuUZCQVKI6vU9YQVOV0AwcnNBytsEXfc0HSer4jGfc0IVYQSL5rGhM3ISlTkEjcnZ+fY363GYK0g",
	"Bmm4OS05ag7vEPp6yIggbypEDpQj8vy566OMz9i8kqDI5QL0wsk8CaoUXAER039Aqs22/++TX14TIckr",
	"UIrO4Q1NzwnwVGTDe+wmjUnwfyhhNrxQ85Km53FxnbOCRUB+RZesqArCq2IK0uyXlw9aEAm6knwIIDvi",
	"Bjor6LI/6amseIqb20zbUtQMKTFV5nS1R45npKDL7/fHDhxFaJ6TEnjG+JzoJR9U0szcm8FLpKh4toUO",
	"o82GBVJTlZCyGYOM1KOsgcRNswkexq8HT6NZBeD4QQbBqWfZAA6HZYRmzNE1X0hJ5xCQzB751XEu/KrF",
	"OfCawZHpCj+VEi6YqFTdaQBGnHq9es2FhqSUMGMRGjtx6DDcw7Zx7LVwCk4quKaMQ2Y4LwItNFhONAhT",
	"MOH6y0xfRE+pgm+fDAnw5uuWuz8T3V1fu+Nb7TY2SuyRjMhF89Ud2Lja1Oq/xeUvnFuxeWJ/7m0km58a",
	"UTJjOYqZf5j982ioFDKBFiK84FFszqmuJByc8W/MXyQhJ5ryjMrM/FLYn15VuWYnbG5+yu1PL8WcpSds",
	"PoDMGtbobQq7FfYfM16cHRtwq5zaNcYOWN3gwpKqOVG1iqAFKUEa6sG1I3yGG4gSJI45RAfhtOsPl15G",
	"bzUvhTivyhDjaevaPF2R46Oh2e2Y1z05h/VdO7z2nC79Vei6PfSyprQBIAc3t6Sm4TmsJBhoaTrDf5Yz",
	"JHg6k3+Yf8oyj226OWFOE0CrhbNmvHW/mZ9wo+2lxYzCUtypCcr3gw8BQP8hYTY6GP37pDHlTOxXNXHj",
	"mhmvxqPDZpy7n6npadfXuWk1nwnjdnew6dheWu8eHjNqFBLUpDsw/JCL9PxGMJTSHDTN7D5OzTj9k4LD",
	"kwXQDCTJqKZ7za3PKoID9I4df8Z+eI0DGZHBv+B/aE7MZ3MKqfb6pdGtmTJapggsYZlRSa2gszOZBqgq",
	"C1JYLZQY7fFaUD5vJrcSpGb57xxa3ndHi+zOC6v4EuzhF2GW3lxrD6dC3oxeOoTASXNZJ9SMWqvnZuXt",
	"ncWmVZk4/EQUftugM1BjH+2z1RBD3eFjuGph4UTTj4AFZUa9Cyy0B7prLIiiZDncwXldULXoL8JoYI8f",
	"kZOfD58+fPT7o6ffGhWilGIuaUGmKw2K3HdyhSi9yuFBf2XI4Ktcx0f/9om/4rXH3YghBLgee5sTdQqG",
	"M1iMEWvQMNAdyZWs+B2gEKQUMqI3IOlokYo8uQCposrNG9eCuBaGD9mLQed3Cy25pMrpNZCRimcg92KY",
	"NxdBFOkaCrVJUNihT5e8wY0bkEpJV70dsOuNrM7Nu82etJHvrx/KKHKJXnKSwbSahzKKzKQoCCUZdkSG",
	"+FpkcKKprtQdcIFmsAYYsxEhCHQqKk0o4SIzB9o0jvOHAWMrWnnQOKVDlqMXVv5MwajvKa3mC02MWili",
	"W9t0TGhqNyVBWaEG7qa1UcG2stNZQ14ugWYrMgXgREzdBdBdTXGRFO1G2ruEHHdqwKovLS24SilSUAqy",
	"xPm/NoLm29ld1mvwhIAjwPUsRAkyo/KGwGqhab4BUGwTA7dWJ9ytuQ/1dtOv28Du5OE2UmkuwZYKjO5i",
	"TncOGoZQuCVOLkDi7fGj7p+f5KbbV5UDvh0ngU9ZYY4v4ZQLBangmYoOllOlk03H1jRqqQlmBcFJiZ1U",
	"HHjAgvGSKm1tCIxnqDJadoPzYB+cYhjgQYliRv7NC5P+2Knhk1xVqpYsqipLITVksTVwWK6Z6zUs67nE",
	"LBi7Fl9akErBppGHsBSM75BlV2IRRLU3AHgjW39x6C8wcmAVRWULiAYR6wA58a0C7Ib27QFAzP2i7omE",
	"w1SHcmqj+niktChLc/50UvG63xCaTmzrQ/1r07ZPXFQ3fD0TYGbXHiYH+aXFrPVsLKjR7XBkUtBzI5tQ",
	"U7O2hD7M5jAmivEUknWUb47liWkVHoENh3RASXa+02C2zuHo0G+U6AaJYMMuDC14QGN/Y030p4116A6U",
	"liPQlOWqVkxqP0AzC7oMuuEcRouUkALX+crQ6ozJwnrdUJwp/5tVezI3i/UvNcePZ0TCJZWZb9G/LQWL",
	"SRjPYBnnrrRlG8lgSVgc6Fk9M9Mk9T4xHg6wFz3o1suY5kIxPk+s+3KTUKu9jvcUqThzAuwSpINrBtKJ",
	"Xe3dd4kW3sW3Do51qHDGmZsgwXSNT2uBs7ulYl5e/GAOYsFSKah13hqkdhZIJBTUQIduRCf2h+dch+zn",
	"9rv3JXsbfki78XE9vQ5ymJpELxe4WYbVdpEYUr252oKCoYXMczGleWIUfkgyyPVG05u5SMARtjTyWqT9",
	"7m2Qz87e5dnZ2Xvy0rTFuwWQc1hN0KVO0gXlc2j8HOF5sbcGWEJahaKlg8atLoLOVtqGvn0VHI9KIfKk",
	"vvJ2/TI9cdPF+zlLzyEjhl/hEXNS8F57h8wk5L4hcVV7ri4XK69CliVwyB7sEXLICRSlXjn7Skfj6UzO",
	"7+l18y9x1qxCJzrlBBe5d8bjpg3rgr/lmfLDrD9JNibtllPZQdZPpJcD/hdJL9GDZIaLns+11tET7BmI",
	"vp5ED4jKQrGNDeEnDNSirV1mGV5HGummqmnBMForaDY2nNM70Ps3fKb3CDlF3mEuWAouQNIcQ1GUNxwz",
	"RQpmLuqqSlOA7OCMJy1IUlG4ie83/7Vs6aza338MZP9Bt4/SRl11d0l7Brp9vyf7Y/sJ0UW+J2ejs1Fv",
	"JAmFuIDM3sdCura9Ng77b/W4Z/yXHmMmBV3Zm5w/i0RVsxlLmUV6Lgxfn4uO1skFfgFpwAMjZhVheoyi",
	"DDGK2rrdl+YAjqLa013YfCKjGj3diFLD7bzbtE07isCSpmaVFJnMymoENZ31lSAtyiQcIGqCXjOjcwKo",
	"Fh+/4bnr83NrgFgP32nHBNFCR0Cue5t19x4yohBsc/wPSSnMrjMXIOWjaHKmdA9IZ45AD1BNkBGhs0f+",
	"j6hISvH8lpWG+m4nJF6Y8CJtZkAZ6+d0mlqDIcihAGshwi/ffNNd+DffuD1niszg0kcVmoZddHzzjT0E",
	"Qulbn4AOaS6PIwoUGuaNNI1Egi+oWuxtNNLjuFvZ5oOhj4/8hHiYlEIRYxYuhZjdwWpZtozqLLCMrdTt",
	"HJrb7ilS0tWgel0aACPhZCDPc7Tli1mHIonjfwtWmiGb0JeVhlbY7P+9/18H7w6T/6HJH/vJs/+cvP/w",
	"5OrBN70fH119//3/a//0+Or7B//1HzHlRWk2jft9fqZqYSB1nGPJj7n13BrNEw12K2cHELNPDXeHxMxm",
	"eswHS9qG6N7ENoQZVQI3G2nupIkNuQNJ08RfIUlRFV6ibWiYwXAQkOI0eqdldXzsVMG6a09tGAvHm8Kc",
	"8bgFNF1Aeo52zY2G3hZTLY2WBcgpgKYL0owTE1WhntmTQecwoHmWIBVTBucOT9NVYPULF2iY9tSo1DOQ",
	"wNOYPbPrlKfWNImzb0M4AVF04ydOqrLMV3dBKjgQkeDupKplTlf2q5iFUdaOU6mV0lD0PVK26+8Dt+W3",
	"3prV2yXBc8YhKQSHVfRhEePwCj9G7xIoxgY6o0Ix1Ldr7WvB3wGrPc9We3hL/CJ3CMTWmzrm+w42vztu",
	"xxkZxpfjTRjyklCS5gxdLYIrLatUn3GKxtzOVa1DFt5EPWzef+6bxP0JEXO/G+qMU2VwWJt4o07qGUS4",
	"2I8A3sqvqvkcVOfqRmYAZ9y1YhwNczgX3nwTu2ElSIwm2LMtzW1lRnP0RvwBUpBppducDMNg7e3LekbN",
	"NETMzjjVJAeqNHnF+OkSh/NWGE8zHPSlkOc1FgasSMBBMZXEBe9P9ivKX7f8hZPF+CbJfvby6VMrDB72",
	"WAykg/z4yF2djo9QP258oj3YP5mjrGA8iRKZESwF4xjr36Etct9o+Z6AHjTeVbfrZ1wvuSGkC5qzjOqb",
	"kUOXxfXOoj0dHappbUTH7+HX+j5mkpmLpKTpOcYrjeZML6rpXiqKib8yTuaivj5OMgqF4Pgtm9CSTYyQ",
	"nVw83KC+34JfkQi7uhqPHNdRdx4Z6QaOLag7Z+1x9H9rQe799OKUTNxOqXs2gtkOHUSyRm757sFwy+Bk",
	"Fm9fHNqQ9TN+xo9gxjgz3w/OeEY1nUypYqmaVArkDzSnPIW9uSAHxA15RDVFO2XH+zL0KBhtyA6asprm",
	"LCXnoShujuaQ8f7s7J0hkLOz9734hL7gdFPFHSI4QXLJ9EJUOnEerGFbp2pp0s53sG7WMXFjW4p0HjI3",
	"/oCTpixVEljt48svy9wsPyBDRbATxrcSpYX0TNBwRmd3Nfv7WrgIDUkv/TOoSoEify9o+Y5x/Z4kzkZ4",
	"WJboEkCb/N8drzE0uSphe7t+A2IzWEwPx4VbhQqWWtKkpHNQ0eVroCXuPgrqAq2ueU6wW8s/4aP7cKhm",
	"AWvt0AEc1469xsWd2F7e4RZfAn7CLcQ2hjs1/pOb7pcZ6meRGyK78XYFY0R3qdKLxJzt6KqUIXG/M/VL",
	"xbnhyfW1kM25OQTuUecU7M0NMnQWoz9l3OruQ3KchPOsgyn7DtOGWONjIX8Lq8qMOh2A8lX3UYQCrf1T",
	"lbdwDqtT0bw1us4rCHN5tQ7QxNDM0EFFSg2EkSHW8Nh6J2pn850/HJ2UZUmsH9BGr3uyOKjpwvcZPshW",
	"Qt7BIY4RRY2GNfReUhlBhCX+ARTcYKFmvFuRftTrSKVmKSvrN0Jb+DHftPqYQTYJl6g4EbOu1Ogx9SgT",
	"s42TuLHm7OwdmC9mP8wZ6ka/+ZmsFdoGNhDM5eEId5pD4IFX7mRTiUqXX7ZNTjAEWpxKQPJGqnsw2hgJ",
	"1YeFCyVhF00ACZoItxG0Gx34hoq8tYe1XXXMzJvDBR30mg4+ojsOAreCt9n1EznP2LqHYVw/l7RpUvxT",
	"Ov9+zj+aG42v9QBuPHKxxLHtEBy1jAxymFPnJMQoZR+gYkG7p4INMnD8MpvljANJYjFgVCmRMhs30vBy",
	"NwcYJfQbQqyBh2w9QoyMA7DRu4IDk9ciPJt8fh0gOTB0x1A/Nvplgr9hs3eiyVfj1NuNamifdzSHaNy8",
	"J7Xb2LdCjUdRljR0Q2i1IrbJFHpXqhiJGtbUt8v0rT8KckBxnLQ4a3Ies9YZrQKQDE98t+DaQO6zmRHy",
	"DwInm4Q5Uxqae7M5rd4Q9GltFxdCQzJjUukEr+zR5ZlGPypUBn80TePsp4UqYhNesCzOfXDac1glGcur",
	"+G67ef96ZKZ9Xd+fVDU9hxUKGbSqTzFBi5FCrelNmzVT2zjItQt+aRf8kt7ZerejJdPUTCyF0J05vhKq",
	"6vCTdYcpQoAx4ujv2iBK17CXIHKrz1uCO5mNL8NYtL11VoPeYbp29Nsg57UjRdcSKLprV2GDJG0cZJDf",
	"pP8mZ+AM0LJk2bJzh7ejDrh5UYG/hqJuNf6I63JUD7YBA8F9PRb2LcHbHOyWBjLTZqrphcZuxkw3IDdg",
	"COFUTPk8a31EGdLGyMVNuDoFmv8VVr+Ztric0dV4dLsrfwzXbsQNuH5Tb28Uz2jLtlfAlgXvmiinZSnF",
	"Bc0TZxgZIk0pLhxpYnNvR/nErC5+/T59cfjyjQMfI32BShfgum5V2K78alZlbsSxKNfTwDKC2qq/O1tF",
	"LNj8+u15aEzxQcktXc5wMUdc9ng1hrLgKDrjyizuUttoKnE2PbvENbY9KGvTXnMjtpa9tjWPXlCW+6uo",
	"h3ZzEPWNuEIrCvu2VsEwJPtO2U3vdMdPR0NdG3hSONeaqJLCJq5SRPBuIJpRIfGGi6Ra0JWhIGuc7jMn",
	"XhWJOX6JylkaN1vwqTLEwa3N1zQm2HhAGTUjVmzAhcArFoxlmqktvGUdIIM5oshEk9Ia3E2FyzhacfbP",
	"CgjLgGvzSbrA1NZBNefSv7Xoi9P4uw43sHvaUQ9/Gx3DDDWkXSAQ6xWM0MIceVXkL5x+obVp3PwQGAav",
	"4agKZ+yJxDVOJkcfjpqtt3/RthSHCUL7/M8Qhk0mtTk7qTdbLCygA3NEs40OSovDYUmB73W2lxGNSEBw",
	"Q2FgY6hprkRkmIpfUm6TB5p+FoeutwJrMzC9LoXER64Kol56ppKZFH9A/CY7MxsViZV1qER1EXvvRR4P",
	"dplobZVp0sJ6/IZwDJL2kCYXfCRtR+LACUcqD0znGPzvDVyUW7K2iQ5b7uv44QhDTiZ2/OZwOJh7YTo5",
	"vZzSWEodo1AZmA4bJ03LFKcF8Z39Lqj6zYujvcDfU7dl9mVoCbIJaO9nIbihcvR1kXwGKStoHteSMsR+",
	"OzwyY3Nms0VWCoJ0hG4gm2bXUpFL6WjdYA1qjmdkfxwkPHW7kbELptg0B2zxcNzEkeLLxPC1oguM0sD1",
	"QmHzR1s0X1Q8k5DphbKIVYLUCqx9hOZt31PQlwCc7GO7h8/IfbT6K3YBDwwWnS4yOnj4DMNS7B/7MWHn",
	"0sKu4ysZMpb/dowlTsfo9rBjGCHlRt2LvlK2ubyHWdia02S7bnOWsKXjepvPUkE5nUPcm1tsgMn2xd1E",
	"o2EHLxhdTDJQWooVYTo+P2hq+NNAaJphfxYM96apsMG4RInC0FOTa9BO6oezWW1dei0Pl/+ILpbSv03r",
	"XJg/rYHYyvLYqtER9poW0EbrmFD7mB+f17kkEI4h7pFjnxIE843VacYsbsxcZumo0pktxLRKjGu8RFV6",
	"lnxH0gWVNDXsb28I3N+n3z4ZAPnbJwboToYlfr01bHmzDNJ0ggJ5EceiHKBgrxi4vuQ+FzwpDHPIHjRR",
	"ncEBi+Y5Eprm8fgUz5y74Unrh95WlzSjJIOUU7UohwZM91Y0xNcMeEuqqtczSFrVetK69iKvTWSVjO80",
	"rQxYv7596WR/IWQsbVNzCOuHAloyuMColzi+zZi3RKvMh89qFUXobRZyTZx2o1BrFbvWe/wJi2naP1Qs",
	"z35rYsc7b1Qk5eki6kSYmo6/N5l1a7js6Yq/UKGcQx4dzgql373wiojXf4ht5ykY37Jt9ymJXW5ncQ3g",
	"bTA9UH5Cg16mczNBiNV2MG0dfZXPRUZwnia7TEMl/UfZQa67f1agdOwBOX6wgYtoLDKKt021RoBn9k0P",
	"sQ+uDSytJ7OoLrKiyu3zS8jmIJ0VsypzQbMxMeOcvjh8SeysyiUPwYe+mOptbh/vt1bRMRIEqaiuk81g",
	"KM5x+3HWB16ZVSuNuWiUpkUZC2E3LU59A4yTDw2nqEeF2NkjR1aFVV5BspM0SStIPZ1jt0gT5j9a03SB",
	"umFLkxom+e1zFHqqVEEy8TrtcZ1NyuZh0MKnKbRZCsdEGAX+kilbEAEuoB01Xz8hcXcTH0XfXp6sOLeU",
	"EmW365443QTtHjjrHfe21ShkHcRfU51QopIpXDdl4wn2ij6o6+Z/7GURt8876yS5vtBNSrngLMUn1UEJ",
	"hhpkV1xhGymzxevzrt3HH3F3QiOHK5p1so6/cVgczEPpGaFDXN/yGXw1m2qpw/6JOcfRojEHrRxng2zs",
	"M4s6gwTjClx2MKyzEfBJIVvOHOSQUf9gkx/ommSEMbQDaumP5ttrd//AuLdzxlGncWhzIXbWZIC537VR",
	"hJgmcwHKraf9Rlq9M3328J1wBsv3ez5XPI5hfSFm2dbx1x/q0LsBndvNtH1u2hL0ezQ/t+J17aSHZekm",
	"jT5xrnc4lht1EMERd07i7ekBcuvxw9HWkNta/z3KU0NocIHePyhRDvcIYyDnzosLmlfuyTCm7rBxM9F3",
	"VoxHwHjJODSVDCICIo2KBNwYPK8D/VQqqbYq4FY87RRoji6/GENT2tlAbztUZ4MRJbhGP8fwNjYZcgcY",
	"R92gUdwoX9UFFAx1B8rEc6zc4hDZz3eLWpVTojKMjOxkwI0xDsO4fe7otgDoH4O+TmS7a0ntybmOJBp6",
	"UZIxZe4qxTSPxIId1R+DLNAYdDpd4b+xZ+TDK3Ae4htn6MKO19Yv12fLys3eJ4rNb7grTf873JbOGQj3",
	"KEb9LwxbCR/h9ZLXWMZTv5HDOBjhc/LjpaJ+3dGmWWR00Utbk159fezdcKL0MbLGgWi4t83zb2q5rzVy",
	"D8XEpYMhnFS7+GxNybq0dTa7eWwE61C3WdVtCbWoKWHIiW596OZzr/d2ekNPC8Ox1yLUR2f0AfqrD/0i",
	"JWXOg9MckT5mXZBoP2x3m/CxZoO7i3ChlzhIbCU3jJTc6uz1sRQ52GGMywbyPG+h1D6p6miSQsIdozYQ",
	"oddEbT96Z9vl4TqQYioF/XVuvQEt3A7gfhvEN3whkoNl8Djr6TbHOf4yxXRHfmIR4t9O9bnJJ+MGraIM",
	"bt7Yrv82ZD2wN+QBQ1UHpxXLs02b2zI7NrkJ0LDmba2fJTvC7zaypH/c3EPx6wj+7iYgYiJrbU0eTBUY",
	"FLewJbpuEcshJp9MK8n0CoPQvKbJfo8G9/8E3JWmcJV+ale+8yTbFD7Obj2vWzeFy34StlZHYdRfVAU1",
	"ZmV7saRFmYM7F9/fm/4FHn/3JNt//PAv0+/2n+6n8OTps/19+uwJffjs8UN49N3TJ/vwcPbts+mj7NGT",
	"R9Mnj558+/RZ+vjJw+mTb5/95Z4vymUBbQpe/Q1TiCSHb46TU8wL1GxNyf4KK5s0wJCxT0dAUzyJUFCW",
	"jw78T//Ln7C9VBRBoWP368j5M0YLrUt1MJlcXl7uhV0mc8wTnGhRpYuJn6efBO/NcW2gtZEruKN16TPr",
	"lnCkcIjf3r44OSWHb473GoIZHYz29/b3HmLWnxI4LdnoYPQYf8LTs8B9nzhiGx18uBqPJguguV64PwrQ",
	"kqX+k7qk8znIPZeXwfx08Wji7TuTDy5a48qMOo+F5/ncnrV9sZ+uYGwNFubOUufyDF7EKfdQbkymNhCN",
	"uHSyPEMLoA0yMqytRtZxFpRVD9I7jVtV4d/FsjfGkinE6sHX7x+G6wEGJZN9meSn313FHqF8gZXyvp4i",
	"sO87Bege7e9/hKJz49YoHpwbVq97cocgti91twa0O1yPUb2iudkuqCsmj3BBD7/aBR1zfKdlOCmxkuJq",
	"PHr6Fe/QMTdsh+YEWwbhWX3u/Cs/5+KS+5ZGS6iKgsoV6gBBgohQ27salALtwEj30nZYNECQhTV4nN+y",
	"tU9Xns7GRNVFN0rJhNFlsL54BqkEipqHkOiiavK5uifIYJMpvjr8Gxq0Xx3+zSZKjtZeDqa3ScPbcuUn",
	"0JF8wz+smvKcX4mQ+VLKVf/riJpd1uqvNmv1Fkx7t7u7nORfbU7yr1slXdZB7ZRwwROOyUougASWtp2O",
	"+kXrqE/3H3+1qzkBecFSIKdQlEJSyfIV+ZXXQUq3U8FrnlPxIGxsLf/pVeBptOhAfQ8Sp00+tAp8ZZvt",
	"Oa1MC1mrDguNF0gPckq5ANVx83yc8swGl3j3sRr7Z9RoQLT5Cux+jHuPrPdiSnrg/flhdXy0jV7eWlPw",
	"ujOmm7fwtVZF36zxfn57z0c1oty4nv7HFEo9OH6gGfGBtR9ZXGzH35/sP/l0EIS78Fpo8iOG4n1kKfNR",
	"TRdxsgr4H+ZLnHzwb1O34Hnu3Xeb27k6f2v5nDmNY/eCxWWmr2uiGRZnebN9et9nZGaGbVlY/2l6jHk1",
	"z3F3bGtDCsvIUenu+I5V7VjVrVhVl6AaJmVrhE8+YGR0yKF6XALL+2ziEF+uaW28JneoFEXDUGag04Wt",
	"QdANQohwOh9RPszm1j1svjV/6YRF4Bb1yMMWZnKOdnxwu2U5Ruz4s/V7X41HKcgI8f3iw/fMZzbD5Jz1",
	"awH/fh+fy9U18Ot3c+7NL1PEEKgWxAXpEbOL14LyeTN5PygC0XIzm9sOwbdBcI+pvXBvF+3xcov42s1D",
	"gbQkCXmNGhoecB8s/2c0Dn1MifyxF/RacCCwZApzClta3Dlla3WhLmZYV6wJ644MqA6TUKU2jFOoiB7x",
	"HHO8nLS077UKxZCUxiJ1YVW3L1M+74r7/WsV9/tct7TPIne+wKvb5+DsH4sVW17pQhtr8nYmEKWpxDW6",
	"ABTLoX1V0jiHbgXPfNBLll1N6oK0Q9e+N65u6pZcujHNdNwEtCyBSnVjNr2dtUi3qwQHacpFHUVMaFOW",
	"NgKKwcs1I2L+c5twmD9v1MmudvKudvLNaid/UnHZBJZaVuXVGdnhGp9VbOrPJTYTlJpGwXJ38xZaPp8M",
	"xRejrXpBPv8HF7YKr7CCMOQDam8rqQuDLvEWU8HXEsNk7IRtSnW6qMrJB/wP6r9XzYsGm+xmYn0z6+St",
	"rTo8utt7x65S9JdfKfrza+q3Mhh0ViuhrIOpMeoM6b85Lb5CS79sSfvRj2uuFpXOxGXwRChQiicfgj+u",
	"Juc0n4vQBBFztppdeJ5TyfTK520xCpbZlzKnmBV1qW06Kp9vwFzSbYaF9qWzcUz2vavBVfFtFTF2RPTP",
	"tmtyo0Lc1uLwMviDyFYdUjLQTXBhbSJqVAvGqYzkAol4xwYwpwVeP2UpMd95G/CrnR1lZ0f5CuwoXwYj",
	"/hqtFW+rNlNFnrCZZaLLybSdA08c/0qmIlv5zPkuf9LVRrb/oea8V5uYf9ukggQ7rgNJKFGpKIGIErh9",
	"8kPSXNjXP36GdXz+l6DRx+P24+hoIYDXlBw75rxjzjvm/CdlzpYnAVb9aTO/2gXv+WtdYHbwgmpb3CnP",
	"eC0ysOO2s0/0cxpTfPviXuz376X11Tt+wvwlpWlnEzUyRaaAAZW0mi+0TTgfrWZRd0xoak9XYq3sm7iJ",
	"bWWnW9ALIDSXQLMVmQKYbTCLbq5LuMhOiVxnYIiztQauUooUlIIsCRPhrgOtzoOALla9Bk8IOAJcz0KU",
	"IDMqbwisvWmvB7Sbl70Gtw53cZfpPtTbTb9uA7uTh9tIpWHBlgqwiIooyhycrhNB4ZY4QQsw+8j75ye5",
	"6fZVJeZa7YP23H49ZQVepjnlQkEqeBaXx1jHdNOxNY3CtSiwwtGflGgKSzPwgH3qJVXapfoNqkm7eaxe",
	"YaYYBngwA7IZ+bc6g1Fv7Kbgcp0F2RowYxJ8POKwXDPXa1jWc4lZpJizqy6zaeQhLAXj13mRdV/xspmO",
	"l7HFXbI8xzj5uDmvBUSDiHWAnPhWAXZDb9oAIEw1iK4LYbcpJ6j8orQoS3P+dFLxut8Qmk5s60P9a9O2",
	"T1zOTYt8PROgQuu1g/zSYtamPF9QRRwcpKDnzvA9d8/1+zCbw5goxlNXGnioYD4r4MS0Co/AhkPatZ2G",
	"x791zjqHo0O/UaIbJIINuzC04Jhm+1VqjRvNcHcX79W2VgfqVVcrnFxSppOZkFZiJli1KhI63p79vynT",
	"rlaacy1p4aIBXN0ry1DcOEHCfxW+dbYg+HAHs/t9a6uZ6kcht4pUb66QWhCzMFJxzXyCKHPeah3zSw8r",
	"22nPO+15pz3vtOed9rzTnnfa8057vnvt+XMFNSeeT/vsK7HcK2RnF/7I6U0+ZT6SRumvVX68JBgV3Zzj",
	"tU9SNNB84srsbHIChiV7oqEftuhYp+ieDwaxWbsNrzENHj8iJz8fPn346PdHT7813GdhSwCGbe/70pZK",
	"r3J44J7u1Sl5/Rs+4BSrXOATPupvP6kPHrba/IzlQJRB1gtsfgQXkBtV3oYQEnMZ6V+PToHmzx1yPlGw",
	"SA/J+HSnroR053Ei7QtNPPy2v2Gb9ipaQWygwMs6etnopXM1/9zY27jpzJ56dBJXdObzvkNBiByZNezp",
	"i3mH0iks4w8OtjVahTt/X+2jEYf46MHDYzs2NJlVKRCmFXEUd60YDOSytrjQMJN9gT59cKXR3DG4rx4Y",
	"NusfsYSmnmhxx6CQaRMj8HkYp62Ts5Zv3pw62lU3b/1YtDtcn2sEscz3hSRzKaryga2Tz1d4JS5Kylfe",
	"DGZ0xcK7jO0D97vl1HXJsh6f3b7qZHhfwZyO3d8tWsglVb7kZGZrTsbrbnQrI27GeFP3a1OdBrveaI3C",
	"gYqE/U30u+zeD9WmvxJkopc8UimsUxdsl1XmX0IkvJHigpmLc5TD9h83NAxhb6NkkAHLQtHQycQafwX+",
	"ll6GeV23sNR/AVmgtuH6y8SpxrfWmxeAKmOtR0YS6xqJLgXNUqowtYcrN/uRdWq9PI5YRhBMDJHsP/Ez",
	"KsbeRtUXx91K420/8XQTYgZjZYvTfF79t3lmdugyqbSwsTNW/FmMFT/4w6cIJZJedg9nUAJ6C0ZKL/WS",
	"R/noBLnjcExecCDe2JZfB0O9M/9nDwFtN2iDC+fGgbwklKQ5QyeP4ErLKtVnnKIZOUB9Pxy5No4Pq6PP",
	"fZO4JyPiaHBDnXGjmM5IbVyOqqUziJVsBvBar6rmc1C6IytmAGfctWKcVNzc/cSMFCyVIrFP0ozKY2TO",
	"nm1Z0BWZ0Rz9IH+AFGRqbmJhTDQaZZVmee58smYaImZnnGqSgxFLr5hRis1w3m5Xxxm44ugeC/E3366O",
	"VBK35Pxkv+J7ard8b3tDE6H97B9qjj9PtbeEZYOQHx+5lP3HR5iFufHG9mD/ZC66gvEkSmSGbbiohi5t",
	"kftGT/YE9KDx67pdP+PmQqIFQVFE9c3IoetK6Z1Fezo6VNPaiI7Hxa/1fSwR2lwk5tqNxWVHc6YX1RTr",
	"rfkEaZO5qJOlTTIKheD4LZvQkuFDlcnFww0azC34FYmwq51u8edxhIR0YE5LvfGY9aW79wOawx1USPqy",
	"yyJt1HV2RYh2RYh2ZWp2RYh2u7srQrQr0bMr0fOvWqJnb62G6NIBbqxQ0UqClGH4LJGQ2plrBh42a9Wy",
	"6Lt2md4j5HRh+D81MgAuQNKcpFRZxYjbaMOCzReaqCpNAbKDM560IElF4Sa+3/zXXnPPqv39x0D2H3T7",
	"WLtFwHn7fVFVxU/oriPfk7PR2ag3koRCXIBLUIvNswr97bbXxmH/rR73F9nbuoKurHFlQcsSjFhT1WzG",
	"UmZRngtzGZiLTowkF/gFpAHO5sAjTNu6RohPjC11EU7UJcKKKd19+X6dctcdctnlW/wYCvYRaMpyVb/w",
	"iNyn8GbTpaxLqpqjW3MVn2kNlP/NOf3dLDk7hzCOGSM4LqnMfIu+8taqZMUzWMZNS+16OhksvUrQBXpW",
	"z8y0rYBjLpyt6lpxY6KtSuOSeSS2rPvGJBAGMtPvnkKrqT1oqK8iXDOQ7v0CWrNyoSDRoimGNgzHOlS4",
	"eh03QYIazJ9pgbO7FdFQ39oPhiWiVZiiURiR2lmgYSrUQCfxKZd9PzE85zpkP3eZVez32irYscFHxvX0",
	"OhiqXZPoJQoX5HpdJIZUPyMueduAIRqrwSU2GCaDXG/UGE5M0yNseTUeYYG5bvc2yGdn7/Ls7Ow9eWmL",
	"0Zm25BxWkwuaV0DSBeVzUDWOwvNin1/ZEKkgRr+Dxq0iWVwh+Tb03RuPkV5JHbPTS/Xajdvv4v2cpeeQ",
	"EcOv8Ii55wSRywS5X5exwpQyl4uVf4tjxeGDPUIOOYGi1CtiOWzH5t2ZnN/T6+ZfhgK8LRkjIaApsAuQ",
	"tzxTfpj1J0mBOXC3nMoOsn4ivRxITyPpZeRqvW0RkchNunOvDYjKQnEXBoqddNxJx5103EnHnXTcScc/",
	"vXTsGaV2ZptPYbb57IabP1EBtV2ttC9sQWG4basY6i2s2U5ipVFt3NmpbUiPYeU4AqSVZHqFVkZast/P",
	"wfz//dV7801eeANkJfPRwWihdXkwmaBWsRBKT0ZX4/Cb6nw0rJTO7QjOwFdKdoGlDt9f/f8AAAD//2//",
	"NnP5DQEA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
