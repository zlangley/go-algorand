// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64, params GetApplicationByIDParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64, params GetAssetByIDParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Create a speculation context starting at the given block.
	// (POST /v2/blocks/{round}/speculation)
	CreateSpeculation(ctx echo.Context, round uint64) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Executes a batch of contract initializations/calls.
	// (POST /v2/contracts/batch)
	ContractBatchExecute(ctx echo.Context, params ContractBatchExecuteParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error

	// (GET /v2/speculation/get/{contract_id}/{key})
	ContractStorageGet(ctx echo.Context, contractId string, key string) error

	// (GET /v2/speculation/get_with_prefix/{contract_id}/{key_prefix})
	ContractStorageGetWithPrefix(ctx echo.Context, contractId string, keyPrefix string) error

	// (POST /v2/speculation/write/{contract_id}/{key})
	ContractStorageWrite(ctx echo.Context, contractId string, key string) error
	// Operates on a speculation object.
	// (POST /v2/speculation/{speculation}/{operation})
	SpeculationOperation(ctx echo.Context, speculation string, operation string) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context, params RawTransactionParams) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context, params TransactionParamsParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
		"format":      true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationByIDParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetByIDParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// CreateSpeculation converts echo context to params.
func (w *ServerInterfaceWrapper) CreateSpeculation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateSpeculation(ctx, round)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// ContractBatchExecute converts echo context to params.
func (w *ServerInterfaceWrapper) ContractBatchExecute(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ContractBatchExecuteParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ContractBatchExecute(ctx, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// ContractStorageGet converts echo context to params.
func (w *ServerInterfaceWrapper) ContractStorageGet(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "contract_id" -------------
	var contractId string

	err = runtime.BindStyledParameter("simple", false, "contract_id", ctx.Param("contract_id"), &contractId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter contract_id: %s", err))
	}

	// ------------- Path parameter "key" -------------
	var key string

	err = runtime.BindStyledParameter("simple", false, "key", ctx.Param("key"), &key)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter key: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ContractStorageGet(ctx, contractId, key)
	return err
}

// ContractStorageGetWithPrefix converts echo context to params.
func (w *ServerInterfaceWrapper) ContractStorageGetWithPrefix(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "contract_id" -------------
	var contractId string

	err = runtime.BindStyledParameter("simple", false, "contract_id", ctx.Param("contract_id"), &contractId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter contract_id: %s", err))
	}

	// ------------- Path parameter "key_prefix" -------------
	var keyPrefix string

	err = runtime.BindStyledParameter("simple", false, "key_prefix", ctx.Param("key_prefix"), &keyPrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter key_prefix: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ContractStorageGetWithPrefix(ctx, contractId, keyPrefix)
	return err
}

// ContractStorageWrite converts echo context to params.
func (w *ServerInterfaceWrapper) ContractStorageWrite(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "contract_id" -------------
	var contractId string

	err = runtime.BindStyledParameter("simple", false, "contract_id", ctx.Param("contract_id"), &contractId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter contract_id: %s", err))
	}

	// ------------- Path parameter "key" -------------
	var key string

	err = runtime.BindStyledParameter("simple", false, "key", ctx.Param("key"), &key)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter key: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ContractStorageWrite(ctx, contractId, key)
	return err
}

// SpeculationOperation converts echo context to params.
func (w *ServerInterfaceWrapper) SpeculationOperation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "speculation" -------------
	var speculation string

	err = runtime.BindStyledParameter("simple", false, "speculation", ctx.Param("speculation"), &speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Path parameter "operation" -------------
	var operation string

	err = runtime.BindStyledParameter("simple", false, "operation", ctx.Param("operation"), &operation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter operation: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SpeculationOperation(ctx, speculation, operation)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params RawTransactionParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx, params)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TransactionParamsParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx, params)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.POST("/v2/blocks/:round/speculation", wrapper.CreateSpeculation, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.POST("/v2/contracts/batch", wrapper.ContractBatchExecute, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/speculation/get/:contract_id/:key", wrapper.ContractStorageGet, m...)
	router.GET("/v2/speculation/get_with_prefix/:contract_id/:key_prefix", wrapper.ContractStorageGetWithPrefix, m...)
	router.POST("/v2/speculation/write/:contract_id/:key", wrapper.ContractStorageWrite, m...)
	router.POST("/v2/speculation/:speculation/:operation", wrapper.SpeculationOperation, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"XwAAAP//su4GuBsiAQA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
