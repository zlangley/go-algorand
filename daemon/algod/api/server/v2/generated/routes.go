// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64, params GetApplicationByIDParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64, params GetAssetByIDParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Create a speculation context starting at the given block.
	// (POST /v2/blocks/{round}/speculation)
	CreateSpeculation(ctx echo.Context, round uint64) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Creates a new contract with the specified identifier and source code
	// (POST /v2/contracts/{id})
	CreateContract(ctx echo.Context, id string, params CreateContractParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Operates on a speculation object.
	// (POST /v2/speculation/{speculation}/{operation})
	SpeculationOperation(ctx echo.Context, speculation string, operation string) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context, params RawTransactionParams) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context, params TransactionParamsParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
		"format":      true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationByIDParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetByIDParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// CreateSpeculation converts echo context to params.
func (w *ServerInterfaceWrapper) CreateSpeculation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateSpeculation(ctx, round)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// CreateContract converts echo context to params.
func (w *ServerInterfaceWrapper) CreateContract(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateContractParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateContract(ctx, id, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// SpeculationOperation converts echo context to params.
func (w *ServerInterfaceWrapper) SpeculationOperation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "speculation" -------------
	var speculation string

	err = runtime.BindStyledParameter("simple", false, "speculation", ctx.Param("speculation"), &speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Path parameter "operation" -------------
	var operation string

	err = runtime.BindStyledParameter("simple", false, "operation", ctx.Param("operation"), &operation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter operation: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SpeculationOperation(ctx, speculation, operation)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params RawTransactionParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx, params)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TransactionParamsParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx, params)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.POST("/v2/blocks/:round/speculation", wrapper.CreateSpeculation, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.POST("/v2/contracts/:id", wrapper.CreateContract, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.POST("/v2/speculation/:speculation/:operation", wrapper.SpeculationOperation, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
