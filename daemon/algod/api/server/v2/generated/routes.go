// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64, params GetApplicationByIDParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64, params GetAssetByIDParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Create a speculation context starting at the given block.
	// (POST /v2/blocks/{round}/speculation)
	CreateSpeculation(ctx echo.Context, round uint64) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Executes a batch of contract initializations/calls.
	// (POST /v2/contracts/batch)
	ContractBatchExecute(ctx echo.Context, params ContractBatchExecuteParams) error
	// Creates a new contract with the specified identifier and source code
	// (POST /v2/contracts/{id})
	CreateContract(ctx echo.Context, id string, params CreateContractParams) error
	// Calls a function on a previously initialized contract.
	// (POST /v2/contracts/{id}/call/{function})
	CallContract(ctx echo.Context, id string, function string, params CallContractParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Operates on a speculation object.
	// (POST /v2/speculation/{speculation}/{operation})
	SpeculationOperation(ctx echo.Context, speculation string, operation string) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context, params RawTransactionParams) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context, params TransactionParamsParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
		"format":      true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationByIDParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetByIDParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// CreateSpeculation converts echo context to params.
func (w *ServerInterfaceWrapper) CreateSpeculation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateSpeculation(ctx, round)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// ContractBatchExecute converts echo context to params.
func (w *ServerInterfaceWrapper) ContractBatchExecute(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ContractBatchExecuteParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ContractBatchExecute(ctx, params)
	return err
}

// CreateContract converts echo context to params.
func (w *ServerInterfaceWrapper) CreateContract(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"sender":      true,
		"address":     true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateContractParams
	// ------------- Optional query parameter "sender" -------------
	if paramValue := ctx.QueryParam("sender"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender", ctx.QueryParams(), &params.Sender)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateContract(ctx, id, params)
	return err
}

// CallContract converts echo context to params.
func (w *ServerInterfaceWrapper) CallContract(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
		"sender":      true,
		"address":     true,
		"args":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "function" -------------
	var function string

	err = runtime.BindStyledParameter("simple", false, "function", ctx.Param("function"), &function)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter function: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CallContractParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Optional query parameter "sender" -------------
	if paramValue := ctx.QueryParam("sender"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender", ctx.QueryParams(), &params.Sender)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "args" -------------
	if paramValue := ctx.QueryParam("args"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "args", ctx.QueryParams(), &params.Args)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter args: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CallContract(ctx, id, function, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// SpeculationOperation converts echo context to params.
func (w *ServerInterfaceWrapper) SpeculationOperation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "speculation" -------------
	var speculation string

	err = runtime.BindStyledParameter("simple", false, "speculation", ctx.Param("speculation"), &speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Path parameter "operation" -------------
	var operation string

	err = runtime.BindStyledParameter("simple", false, "operation", ctx.Param("operation"), &operation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter operation: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SpeculationOperation(ctx, speculation, operation)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params RawTransactionParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx, params)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TransactionParamsParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx, params)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.POST("/v2/blocks/:round/speculation", wrapper.CreateSpeculation, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.POST("/v2/contracts/batch", wrapper.ContractBatchExecute, m...)
	router.POST("/v2/contracts/:id", wrapper.CreateContract, m...)
	router.POST("/v2/contracts/:id/call/:function", wrapper.CallContract, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.POST("/v2/speculation/:speculation/:operation", wrapper.SpeculationOperation, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"1f8EAAD//4cBAL0aHwEA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
