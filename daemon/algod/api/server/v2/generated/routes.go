// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64, params GetApplicationByIDParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64, params GetAssetByIDParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Create a speculation context starting at the given block.
	// (POST /v2/blocks/{round}/speculation)
	CreateSpeculation(ctx echo.Context, round uint64) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Executes a batch of contract initializations/calls.
	// (POST /v2/contracts/batch)
	ContractBatchExecute(ctx echo.Context, params ContractBatchExecuteParams) error
	// Creates a new contract with the specified identifier and source code
	// (POST /v2/contracts/{id})
	CreateContract(ctx echo.Context, id string, params CreateContractParams) error
	// Calls a function on a previously initialized contract.
	// (POST /v2/contracts/{id}/call/{function})
	CallContract(ctx echo.Context, id string, function string, params CallContractParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Operates on a speculation object.
	// (POST /v2/speculation/{speculation}/{operation})
	SpeculationOperation(ctx echo.Context, speculation string, operation string) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context, params RawTransactionParams) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context, params TransactionParamsParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
		"format":      true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationByIDParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetByIDParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// CreateSpeculation converts echo context to params.
func (w *ServerInterfaceWrapper) CreateSpeculation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateSpeculation(ctx, round)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// ContractBatchExecute converts echo context to params.
func (w *ServerInterfaceWrapper) ContractBatchExecute(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ContractBatchExecuteParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ContractBatchExecute(ctx, params)
	return err
}

// CreateContract converts echo context to params.
func (w *ServerInterfaceWrapper) CreateContract(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"sender":      true,
		"address":     true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateContractParams
	// ------------- Optional query parameter "sender" -------------
	if paramValue := ctx.QueryParam("sender"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender", ctx.QueryParams(), &params.Sender)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateContract(ctx, id, params)
	return err
}

// CallContract converts echo context to params.
func (w *ServerInterfaceWrapper) CallContract(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
		"sender":      true,
		"address":     true,
		"args":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "function" -------------
	var function string

	err = runtime.BindStyledParameter("simple", false, "function", ctx.Param("function"), &function)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter function: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CallContractParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Optional query parameter "sender" -------------
	if paramValue := ctx.QueryParam("sender"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender", ctx.QueryParams(), &params.Sender)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "args" -------------
	if paramValue := ctx.QueryParam("args"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "args", ctx.QueryParams(), &params.Args)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter args: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CallContract(ctx, id, function, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// SpeculationOperation converts echo context to params.
func (w *ServerInterfaceWrapper) SpeculationOperation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "speculation" -------------
	var speculation string

	err = runtime.BindStyledParameter("simple", false, "speculation", ctx.Param("speculation"), &speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Path parameter "operation" -------------
	var operation string

	err = runtime.BindStyledParameter("simple", false, "operation", ctx.Param("operation"), &operation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter operation: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SpeculationOperation(ctx, speculation, operation)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params RawTransactionParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx, params)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TransactionParamsParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx, params)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.POST("/v2/blocks/:round/speculation", wrapper.CreateSpeculation, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.POST("/v2/contracts/batch", wrapper.ContractBatchExecute, m...)
	router.POST("/v2/contracts/:id", wrapper.CreateContract, m...)
	router.POST("/v2/contracts/:id/call/:function", wrapper.CallContract, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.POST("/v2/speculation/:speculation/:operation", wrapper.SpeculationOperation, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
