// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64, params GetApplicationByIDParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64, params GetAssetByIDParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Create a speculation context starting at the given block.
	// (POST /v2/blocks/{round}/speculation)
	CreateSpeculation(ctx echo.Context, round uint64) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Executes a batch of contract initializations/calls.
	// (POST /v2/contracts/batch)
	ContractBatchExecute(ctx echo.Context, params ContractBatchExecuteParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Operates on a speculation object.
	// (POST /v2/speculation/{speculation}/{operation})
	SpeculationOperation(ctx echo.Context, speculation string, operation string) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context, params RawTransactionParams) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context, params TransactionParamsParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
		"format":      true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationByIDParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetByIDParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// CreateSpeculation converts echo context to params.
func (w *ServerInterfaceWrapper) CreateSpeculation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateSpeculation(ctx, round)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// ContractBatchExecute converts echo context to params.
func (w *ServerInterfaceWrapper) ContractBatchExecute(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ContractBatchExecuteParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ContractBatchExecute(ctx, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// SpeculationOperation converts echo context to params.
func (w *ServerInterfaceWrapper) SpeculationOperation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "speculation" -------------
	var speculation string

	err = runtime.BindStyledParameter("simple", false, "speculation", ctx.Param("speculation"), &speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Path parameter "operation" -------------
	var operation string

	err = runtime.BindStyledParameter("simple", false, "operation", ctx.Param("operation"), &operation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter operation: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SpeculationOperation(ctx, speculation, operation)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params RawTransactionParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx, params)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TransactionParamsParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx, params)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.POST("/v2/blocks/:round/speculation", wrapper.CreateSpeculation, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.POST("/v2/contracts/batch", wrapper.ContractBatchExecute, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.POST("/v2/speculation/:speculation/:operation", wrapper.SpeculationOperation, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"KZ3bEZyBr5TsAqtUv7/6nwAAAP//3VcUVwYgAQA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
