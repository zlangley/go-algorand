// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64, params GetApplicationByIDParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64, params GetAssetByIDParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Create a speculation context starting at the given block.
	// (POST /v2/blocks/{round}/speculation)
	CreateSpeculation(ctx echo.Context, round uint64) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Executes a batch of contract initializations/calls.
	// (POST /v2/contracts/batch)
	ContractBatchExecute(ctx echo.Context, params ContractBatchExecuteParams) error
	// Creates a new contract with the specified identifier and source code
	// (POST /v2/contracts/{id})
	CreateContract(ctx echo.Context, id string, params CreateContractParams) error
	// Calls a function on a previously initialized contract.
	// (POST /v2/contracts/{id}/call/{function})
	CallContract(ctx echo.Context, id string, function string, params CallContractParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Operates on a speculation object.
	// (POST /v2/speculation/{speculation}/{operation})
	SpeculationOperation(ctx echo.Context, speculation string, operation string) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context, params RawTransactionParams) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context, params TransactionParamsParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
		"format":      true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationByIDParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetByIDParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// CreateSpeculation converts echo context to params.
func (w *ServerInterfaceWrapper) CreateSpeculation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateSpeculation(ctx, round)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// ContractBatchExecute converts echo context to params.
func (w *ServerInterfaceWrapper) ContractBatchExecute(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ContractBatchExecuteParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ContractBatchExecute(ctx, params)
	return err
}

// CreateContract converts echo context to params.
func (w *ServerInterfaceWrapper) CreateContract(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"sender":      true,
		"address":     true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateContractParams
	// ------------- Optional query parameter "sender" -------------
	if paramValue := ctx.QueryParam("sender"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender", ctx.QueryParams(), &params.Sender)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateContract(ctx, id, params)
	return err
}

// CallContract converts echo context to params.
func (w *ServerInterfaceWrapper) CallContract(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
		"sender":      true,
		"address":     true,
		"args":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "function" -------------
	var function string

	err = runtime.BindStyledParameter("simple", false, "function", ctx.Param("function"), &function)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter function: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CallContractParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Optional query parameter "sender" -------------
	if paramValue := ctx.QueryParam("sender"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender", ctx.QueryParams(), &params.Sender)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "args" -------------
	if paramValue := ctx.QueryParam("args"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "args", ctx.QueryParams(), &params.Args)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter args: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CallContract(ctx, id, function, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// SpeculationOperation converts echo context to params.
func (w *ServerInterfaceWrapper) SpeculationOperation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "speculation" -------------
	var speculation string

	err = runtime.BindStyledParameter("simple", false, "speculation", ctx.Param("speculation"), &speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Path parameter "operation" -------------
	var operation string

	err = runtime.BindStyledParameter("simple", false, "operation", ctx.Param("operation"), &operation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter operation: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SpeculationOperation(ctx, speculation, operation)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params RawTransactionParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx, params)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TransactionParamsParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx, params)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.POST("/v2/blocks/:round/speculation", wrapper.CreateSpeculation, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.POST("/v2/contracts/batch", wrapper.ContractBatchExecute, m...)
	router.POST("/v2/contracts/:id", wrapper.CreateContract, m...)
	router.POST("/v2/contracts/:id/call/:function", wrapper.CallContract, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.POST("/v2/speculation/:speculation/:operation", wrapper.SpeculationOperation, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
