// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64, params GetApplicationByIDParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64, params GetAssetByIDParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Create a speculation context starting at the given block.
	// (POST /v2/blocks/{round}/speculation)
	CreateSpeculation(ctx echo.Context, round uint64) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Executes a batch of contract initializations/calls.
	// (POST /v2/contracts/batch)
	ContractBatchExecute(ctx echo.Context, params ContractBatchExecuteParams) error
	// Creates a new contract with the specified identifier and source code
	// (POST /v2/contracts/{id})
	CreateContract(ctx echo.Context, id string, params CreateContractParams) error
	// Calls a function on a previously initialized contract.
	// (POST /v2/contracts/{id}/call/{function})
	CallContract(ctx echo.Context, id string, function string, params CallContractParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Operates on a speculation object.
	// (POST /v2/speculation/{speculation}/{operation})
	SpeculationOperation(ctx echo.Context, speculation string, operation string) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context, params RawTransactionParams) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context, params TransactionParamsParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
		"format":      true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationByIDParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetByIDParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// CreateSpeculation converts echo context to params.
func (w *ServerInterfaceWrapper) CreateSpeculation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateSpeculation(ctx, round)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// ContractBatchExecute converts echo context to params.
func (w *ServerInterfaceWrapper) ContractBatchExecute(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ContractBatchExecuteParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ContractBatchExecute(ctx, params)
	return err
}

// CreateContract converts echo context to params.
func (w *ServerInterfaceWrapper) CreateContract(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"sender":      true,
		"address":     true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateContractParams
	// ------------- Optional query parameter "sender" -------------
	if paramValue := ctx.QueryParam("sender"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender", ctx.QueryParams(), &params.Sender)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateContract(ctx, id, params)
	return err
}

// CallContract converts echo context to params.
func (w *ServerInterfaceWrapper) CallContract(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
		"sender":      true,
		"address":     true,
		"args":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "function" -------------
	var function string

	err = runtime.BindStyledParameter("simple", false, "function", ctx.Param("function"), &function)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter function: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CallContractParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Optional query parameter "sender" -------------
	if paramValue := ctx.QueryParam("sender"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender", ctx.QueryParams(), &params.Sender)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "args" -------------
	if paramValue := ctx.QueryParam("args"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "args", ctx.QueryParams(), &params.Args)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter args: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CallContract(ctx, id, function, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// SpeculationOperation converts echo context to params.
func (w *ServerInterfaceWrapper) SpeculationOperation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "speculation" -------------
	var speculation string

	err = runtime.BindStyledParameter("simple", false, "speculation", ctx.Param("speculation"), &speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Path parameter "operation" -------------
	var operation string

	err = runtime.BindStyledParameter("simple", false, "operation", ctx.Param("operation"), &operation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter operation: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SpeculationOperation(ctx, speculation, operation)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params RawTransactionParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx, params)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TransactionParamsParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx, params)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.POST("/v2/blocks/:round/speculation", wrapper.CreateSpeculation, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.POST("/v2/contracts/batch", wrapper.ContractBatchExecute, m...)
	router.POST("/v2/contracts/:id", wrapper.CreateContract, m...)
	router.POST("/v2/contracts/:id/call/:function", wrapper.CallContract, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.POST("/v2/speculation/:speculation/:operation", wrapper.SpeculationOperation, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
