// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64, params GetApplicationByIDParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64, params GetAssetByIDParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Create a speculation context starting at the given block.
	// (POST /v2/blocks/{round}/speculation)
	CreateSpeculation(ctx echo.Context, round uint64) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Executes a batch of contract initializations/calls.
	// (POST /v2/contracts/batch)
	ContractBatchExecute(ctx echo.Context, params ContractBatchExecuteParams) error
	// Creates a new contract with the specified identifier and source code
	// (POST /v2/contracts/{id})
	CreateContract(ctx echo.Context, id string, params CreateContractParams) error
	// Calls a function on a previously initialized contract.
	// (POST /v2/contracts/{id}/call/{function})
	CallContract(ctx echo.Context, id string, function string, params CallContractParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Operates on a speculation object.
	// (POST /v2/speculation/{speculation}/{operation})
	SpeculationOperation(ctx echo.Context, speculation string, operation string) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context, params RawTransactionParams) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context, params TransactionParamsParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
		"format":      true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationByIDParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetByIDParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// CreateSpeculation converts echo context to params.
func (w *ServerInterfaceWrapper) CreateSpeculation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateSpeculation(ctx, round)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// ContractBatchExecute converts echo context to params.
func (w *ServerInterfaceWrapper) ContractBatchExecute(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ContractBatchExecuteParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ContractBatchExecute(ctx, params)
	return err
}

// CreateContract converts echo context to params.
func (w *ServerInterfaceWrapper) CreateContract(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"sender":      true,
		"address":     true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateContractParams
	// ------------- Optional query parameter "sender" -------------
	if paramValue := ctx.QueryParam("sender"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender", ctx.QueryParams(), &params.Sender)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateContract(ctx, id, params)
	return err
}

// CallContract converts echo context to params.
func (w *ServerInterfaceWrapper) CallContract(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
		"sender":      true,
		"address":     true,
		"args":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "function" -------------
	var function string

	err = runtime.BindStyledParameter("simple", false, "function", ctx.Param("function"), &function)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter function: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params CallContractParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Optional query parameter "sender" -------------
	if paramValue := ctx.QueryParam("sender"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender", ctx.QueryParams(), &params.Sender)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "args" -------------
	if paramValue := ctx.QueryParam("args"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "args", ctx.QueryParams(), &params.Args)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter args: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CallContract(ctx, id, function, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// SpeculationOperation converts echo context to params.
func (w *ServerInterfaceWrapper) SpeculationOperation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "speculation" -------------
	var speculation string

	err = runtime.BindStyledParameter("simple", false, "speculation", ctx.Param("speculation"), &speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Path parameter "operation" -------------
	var operation string

	err = runtime.BindStyledParameter("simple", false, "operation", ctx.Param("operation"), &operation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter operation: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SpeculationOperation(ctx, speculation, operation)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params RawTransactionParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx, params)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TransactionParamsParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx, params)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.POST("/v2/blocks/:round/speculation", wrapper.CreateSpeculation, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.POST("/v2/contracts/batch", wrapper.ContractBatchExecute, m...)
	router.POST("/v2/contracts/:id", wrapper.CreateContract, m...)
	router.POST("/v2/contracts/:id/call/:function", wrapper.CallContract, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.POST("/v2/speculation/:speculation/:operation", wrapper.SpeculationOperation, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
