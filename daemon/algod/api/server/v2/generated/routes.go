// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64, params GetApplicationByIDParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64, params GetAssetByIDParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Create a speculation context starting at the given block.
	// (POST /v2/blocks/{round}/speculation)
	CreateSpeculation(ctx echo.Context, round uint64) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Executes a batch of contract initializations/calls.
	// (POST /v2/contracts/batch)
	ContractBatchExecute(ctx echo.Context, params ContractBatchExecuteParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error

	// (GET /v2/speculation/read/{contract_id}/{key})
	ContractStorageGet(ctx echo.Context, contractId string, key string) error

	// (POST /v2/speculation/write/{contract_id}/{key})
	ContractStorageWrite(ctx echo.Context, contractId string, key string) error
	// Operates on a speculation object.
	// (POST /v2/speculation/{speculation}/{operation})
	SpeculationOperation(ctx echo.Context, speculation string, operation string) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context, params RawTransactionParams) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context, params TransactionParamsParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
		"format":      true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationByIDParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetByIDParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// CreateSpeculation converts echo context to params.
func (w *ServerInterfaceWrapper) CreateSpeculation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateSpeculation(ctx, round)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// ContractBatchExecute converts echo context to params.
func (w *ServerInterfaceWrapper) ContractBatchExecute(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ContractBatchExecuteParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ContractBatchExecute(ctx, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// ContractStorageGet converts echo context to params.
func (w *ServerInterfaceWrapper) ContractStorageGet(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "contract_id" -------------
	var contractId string

	err = runtime.BindStyledParameter("simple", false, "contract_id", ctx.Param("contract_id"), &contractId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter contract_id: %s", err))
	}

	// ------------- Path parameter "key" -------------
	var key string

	err = runtime.BindStyledParameter("simple", false, "key", ctx.Param("key"), &key)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter key: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ContractStorageGet(ctx, contractId, key)
	return err
}

// ContractStorageWrite converts echo context to params.
func (w *ServerInterfaceWrapper) ContractStorageWrite(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "contract_id" -------------
	var contractId string

	err = runtime.BindStyledParameter("simple", false, "contract_id", ctx.Param("contract_id"), &contractId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter contract_id: %s", err))
	}

	// ------------- Path parameter "key" -------------
	var key string

	err = runtime.BindStyledParameter("simple", false, "key", ctx.Param("key"), &key)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter key: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ContractStorageWrite(ctx, contractId, key)
	return err
}

// SpeculationOperation converts echo context to params.
func (w *ServerInterfaceWrapper) SpeculationOperation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "speculation" -------------
	var speculation string

	err = runtime.BindStyledParameter("simple", false, "speculation", ctx.Param("speculation"), &speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Path parameter "operation" -------------
	var operation string

	err = runtime.BindStyledParameter("simple", false, "operation", ctx.Param("operation"), &operation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter operation: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SpeculationOperation(ctx, speculation, operation)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params RawTransactionParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx, params)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TransactionParamsParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx, params)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.POST("/v2/blocks/:round/speculation", wrapper.CreateSpeculation, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.POST("/v2/contracts/batch", wrapper.ContractBatchExecute, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET("/v2/speculation/read/:contract_id/:key", wrapper.ContractStorageGet, m...)
	router.POST("/v2/speculation/write/:contract_id/:key", wrapper.ContractStorageWrite, m...)
	router.POST("/v2/speculation/:speculation/:operation", wrapper.SpeculationOperation, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
