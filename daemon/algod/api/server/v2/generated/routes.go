// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool by address.
	// (GET /v2/accounts/{address}/transactions/pending)
	GetPendingTransactionsByAddress(ctx echo.Context, address string, params GetPendingTransactionsByAddressParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64, params GetApplicationByIDParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64, params GetAssetByIDParams) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Create a speculation context starting at the given block.
	// (POST /v2/blocks/{round}/speculation)
	CreateSpeculation(ctx echo.Context, round uint64) error
	// Get a Merkle proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetProof(ctx echo.Context, round uint64, txid string, params GetProofParams) error
	// Executes a batch of contract initializations/calls.
	// (POST /v2/contracts/batch)
	ContractBatchExecute(ctx echo.Context, params ContractBatchExecuteParams) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Operates on a speculation object.
	// (POST /v2/speculation/{speculation}/{operation})
	SpeculationOperation(ctx echo.Context, speculation string, operation string) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Broadcasts a raw transaction to the network.
	// (POST /v2/transactions)
	RawTransaction(ctx echo.Context, params RawTransactionParams) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context, params TransactionParamsParams) error
	// Get a list of unconfirmed transactions currently in the transaction pool.
	// (GET /v2/transactions/pending)
	GetPendingTransactions(ctx echo.Context, params GetPendingTransactionsParams) error
	// Get a specific pending transaction.
	// (GET /v2/transactions/pending/{txid})
	PendingTransactionInformation(ctx echo.Context, txid string, params PendingTransactionInformationParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
		"format":      true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// GetPendingTransactionsByAddress converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactionsByAddress(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameter("simple", false, "address", ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsByAddressParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactionsByAddress(ctx, address, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationByIDParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetByIDParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId, params)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// CreateSpeculation converts echo context to params.
func (w *ServerInterfaceWrapper) CreateSpeculation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateSpeculation(ctx, round)
	return err
}

// GetProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetProof(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProofParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProof(ctx, round, txid, params)
	return err
}

// ContractBatchExecute converts echo context to params.
func (w *ServerInterfaceWrapper) ContractBatchExecute(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ContractBatchExecuteParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ContractBatchExecute(ctx, params)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// SpeculationOperation converts echo context to params.
func (w *ServerInterfaceWrapper) SpeculationOperation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "speculation" -------------
	var speculation string

	err = runtime.BindStyledParameter("simple", false, "speculation", ctx.Param("speculation"), &speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// ------------- Path parameter "operation" -------------
	var operation string

	err = runtime.BindStyledParameter("simple", false, "operation", ctx.Param("operation"), &operation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter operation: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SpeculationOperation(ctx, speculation, operation)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameter("simple", false, "round", ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// RawTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) RawTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params RawTransactionParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RawTransaction(ctx, params)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"speculation": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TransactionParamsParams
	// ------------- Optional query parameter "speculation" -------------
	if paramValue := ctx.QueryParam("speculation"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "speculation", ctx.QueryParams(), &params.Speculation)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter speculation: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx, params)
	return err
}

// GetPendingTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPendingTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"max":    true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPendingTransactionsParams
	// ------------- Optional query parameter "max" -------------
	if paramValue := ctx.QueryParam("max"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPendingTransactions(ctx, params)
	return err
}

// PendingTransactionInformation converts echo context to params.
func (w *ServerInterfaceWrapper) PendingTransactionInformation(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
		"format": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set("api_key.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params PendingTransactionInformationParams
	// ------------- Optional query parameter "format" -------------
	if paramValue := ctx.QueryParam("format"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PendingTransactionInformation(ctx, txid, params)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET("/v2/accounts/:address/transactions/pending", wrapper.GetPendingTransactionsByAddress, m...)
	router.GET("/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET("/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET("/v2/blocks/:round", wrapper.GetBlock, m...)
	router.POST("/v2/blocks/:round/speculation", wrapper.CreateSpeculation, m...)
	router.GET("/v2/blocks/:round/transactions/:txid/proof", wrapper.GetProof, m...)
	router.POST("/v2/contracts/batch", wrapper.ContractBatchExecute, m...)
	router.GET("/v2/ledger/supply", wrapper.GetSupply, m...)
	router.POST("/v2/speculation/:speculation/:operation", wrapper.SpeculationOperation, m...)
	router.GET("/v2/status", wrapper.GetStatus, m...)
	router.GET("/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST("/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST("/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.POST("/v2/transactions", wrapper.RawTransaction, m...)
	router.GET("/v2/transactions/params", wrapper.TransactionParams, m...)
	router.GET("/v2/transactions/pending", wrapper.GetPendingTransactions, m...)
	router.GET("/v2/transactions/pending/:txid", wrapper.PendingTransactionInformation, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
